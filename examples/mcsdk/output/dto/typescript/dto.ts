// 
// https://github.com/AlexanderZvyagin/dto-code-generator
// Generated by CODE GENERATOR OF DATA TRANSFER OBJECTS (cgdto) version 0.8.2
// 
// Generated from schema: MonteCarlo SDK version (0.7.0)
// 

function list_equal<Type> (
    a:Type[],
    b:Type[],
    eq:(a:Type,b:Type)=>boolean
): boolean {
    if(a.length!==b.length)
        return false;
    for(let i=0; i<a.length; i++)
        if(!eq(a[i],b[i]))
            return false;
    return true;
}

function float_equal (a:number, b:number) : boolean {
    if(Number.isNaN(a) && Number.isNaN(b)) return true;
    return a===b;
}

function int_equal (a:number, b:number) : boolean {
    return a===b;
}

function string_equal (a:string, b:string) : boolean {
    return a===b;
}


class Error {

    message : string|undefined;
    details : string|undefined;
    code : number|undefined;
    errors : Error[]|undefined;

    constructor(
        message : string|undefined  = undefined,
        details : string|undefined  = undefined,
        code : number|undefined  = undefined,
        errors : Error[]|undefined  = undefined,
    ){
        this.message = message;
        this.details = details;
        this.code = code;
        this.errors = errors;
    
    }

    json (): string {
        return Error_to_json_string(this);
    }
}
export function
Error_equal (a: Error, b: Error) : boolean {
    if(a.message===undefined && b.message!==undefined) return false;
    if(a.message!==undefined && b.message===undefined) return false;
    if(a.message!==undefined && b.message!==undefined)
    if(!string_equal(a.message!,b.message!)) return false;
    if(a.details===undefined && b.details!==undefined) return false;
    if(a.details!==undefined && b.details===undefined) return false;
    if(a.details!==undefined && b.details!==undefined)
    if(!string_equal(a.details!,b.details!)) return false;
    if(a.code===undefined && b.code!==undefined) return false;
    if(a.code!==undefined && b.code===undefined) return false;
    if(a.code!==undefined && b.code!==undefined)
    if(!int_equal(a.code!,b.code!)) return false;
    if(a.errors===undefined && b.errors!==undefined) return false;
    if(a.errors!==undefined && b.errors===undefined) return false;
    if(a.errors!==undefined && b.errors!==undefined)
        if(!list_equal(a.errors!,b.errors!,Error_equal)) return false;
    return true;
}

export function
Error_fromJSON (j:any, obj: Error): void {
    if("message" in j)
        obj.message = j["message"];
    if("details" in j)
        obj.details = j["details"];
    if("code" in j)
        obj.code = j["code"];
    if("errors" in j)
        obj.errors = j["errors"];
}
export function
Error_fromJSON_string (jstr:string): Error {
    const j = JSON.parse(jstr);
    const obj = new Error();
    Error_fromJSON(j,obj);
    return obj;
}
export function
Error_from_json_string (jstr:string): Error {
    const j: object = JSON.parse(jstr);
    const obj: Error = new Error();
    Error_from_json(j,obj);
    return obj;
}

export function
Error_to_json_string (self:Error) {
    const j = {};
    Error_to_json(j,self);
    return JSON.stringify(j);
}

export function
Error_from_json(j:object, obj:Error) {
    if("message" in j)
        obj.message = j["message"] as string|undefined;
    else
        obj.message = undefined;
    if("details" in j)
        obj.details = j["details"] as string|undefined;
    else
        obj.details = undefined;
    if("code" in j)
        obj.code = j["code"] as number|undefined;
    else
        obj.code = undefined;
    if( "errors" in j)
        obj.errors = j["errors"] as Error[]|undefined;
}

export function
Error_to_json(j:object, obj:Error) {
    if( obj.message !== undefined) {
        j["message"] = obj.message;
    }
    if( obj.details !== undefined) {
        j["details"] = obj.details;
    }
    if( obj.code !== undefined) {
        j["code"] = obj.code;
    }
    if( obj.errors !== undefined) {
        j["errors"] = [];
        for(let item of obj.errors) {
            const jj = {};
            Error_to_json(jj,item);
            j["errors"].push(jj);
        }
    }
}


class UpdaterDoc {

    name : string;
    title : string;
    doc_md : string;
    start : string;
    nargs_min : number;
    nrefs_min : number;

    constructor(
        name : string  = "",
        title : string  = "",
        doc_md : string  = "",
        start : string  = "",
        nargs_min : number  = -88,
        nrefs_min : number  = -88,
    ){
        this.name = name;
        this.title = title;
        this.doc_md = doc_md;
        this.start = start;
        this.nargs_min = nargs_min;
        this.nrefs_min = nrefs_min;
    
    }

    json (): string {
        return UpdaterDoc_to_json_string(this);
    }
}
export function
UpdaterDoc_equal (a: UpdaterDoc, b: UpdaterDoc) : boolean {
    if(!string_equal(a.name,b.name)) return false;
    if(!string_equal(a.title,b.title)) return false;
    if(!string_equal(a.doc_md,b.doc_md)) return false;
    if(!string_equal(a.start,b.start)) return false;
    if(!int_equal(a.nargs_min,b.nargs_min)) return false;
    if(!int_equal(a.nrefs_min,b.nrefs_min)) return false;
    return true;
}

export function
UpdaterDoc_fromJSON (j:any, obj: UpdaterDoc): void {
    obj.name = j["name"];
    obj.title = j["title"];
    obj.doc_md = j["doc_md"];
    obj.start = j["start"];
    obj.nargs_min = j["nargs_min"];
    obj.nrefs_min = j["nrefs_min"];
}
export function
UpdaterDoc_fromJSON_string (jstr:string): UpdaterDoc {
    const j = JSON.parse(jstr);
    const obj = new UpdaterDoc();
    UpdaterDoc_fromJSON(j,obj);
    return obj;
}
export function
UpdaterDoc_from_json_string (jstr:string): UpdaterDoc {
    const j: object = JSON.parse(jstr);
    const obj: UpdaterDoc = new UpdaterDoc();
    UpdaterDoc_from_json(j,obj);
    return obj;
}

export function
UpdaterDoc_to_json_string (self:UpdaterDoc) {
    const j = {};
    UpdaterDoc_to_json(j,self);
    return JSON.stringify(j);
}

export function
UpdaterDoc_from_json(j:object, obj:UpdaterDoc) {
    obj.name = j["name"];
    obj.title = j["title"];
    obj.doc_md = j["doc_md"];
    obj.start = j["start"];
    obj.nargs_min = j["nargs_min"];
    obj.nrefs_min = j["nrefs_min"];
}

export function
UpdaterDoc_to_json(j:object, obj:UpdaterDoc) {
    j["name"] = obj.name;
    j["title"] = obj.title;
    j["doc_md"] = obj.doc_md;
    j["start"] = obj.start;
    j["nargs_min"] = obj.nargs_min;
    j["nrefs_min"] = obj.nrefs_min;
}


class UpdaterDto {

    name : string;
    refs : number[]|undefined;
    args : number[]|undefined;
    start : number[]|undefined;

    constructor(
        name : string  = "",
        refs : number[]|undefined  = undefined,
        args : number[]|undefined  = undefined,
        start : number[]|undefined  = undefined,
    ){
        this.name = name;
        this.refs = refs;
        this.args = args;
        this.start = start;
    
    }

    json (): string {
        return UpdaterDto_to_json_string(this);
    }
}
export function
UpdaterDto_equal (a: UpdaterDto, b: UpdaterDto) : boolean {
    if(!string_equal(a.name,b.name)) return false;
    if(a.refs===undefined && b.refs!==undefined) return false;
    if(a.refs!==undefined && b.refs===undefined) return false;
    if(a.refs!==undefined && b.refs!==undefined)
        if(!list_equal(a.refs!,b.refs!,int_equal)) return false;
    if(a.args===undefined && b.args!==undefined) return false;
    if(a.args!==undefined && b.args===undefined) return false;
    if(a.args!==undefined && b.args!==undefined)
        if(!list_equal(a.args!,b.args!,float_equal)) return false;
    if(a.start===undefined && b.start!==undefined) return false;
    if(a.start!==undefined && b.start===undefined) return false;
    if(a.start!==undefined && b.start!==undefined)
        if(!list_equal(a.start!,b.start!,float_equal)) return false;
    return true;
}

export function
UpdaterDto_fromJSON (j:any, obj: UpdaterDto): void {
    obj.name = j["name"];
    if("refs" in j)
        obj.refs = j["refs"];
    if("args" in j)
        obj.args = j["args"];
    if("start" in j)
        obj.start = j["start"];
}
export function
UpdaterDto_fromJSON_string (jstr:string): UpdaterDto {
    const j = JSON.parse(jstr);
    const obj = new UpdaterDto();
    UpdaterDto_fromJSON(j,obj);
    return obj;
}
export function
UpdaterDto_from_json_string (jstr:string): UpdaterDto {
    const j: object = JSON.parse(jstr);
    const obj: UpdaterDto = new UpdaterDto();
    UpdaterDto_from_json(j,obj);
    return obj;
}

export function
UpdaterDto_to_json_string (self:UpdaterDto) {
    const j = {};
    UpdaterDto_to_json(j,self);
    return JSON.stringify(j);
}

export function
UpdaterDto_from_json(j:object, obj:UpdaterDto) {
    obj.name = j["name"];
    if("refs" in j)
        obj.refs = j["refs"] as number[]|undefined;
    else
        obj.refs = undefined;
    if("args" in j)
        obj.args = j["args"] as number[]|undefined;
    else
        obj.args = undefined;
    if("start" in j)
        obj.start = j["start"] as number[]|undefined;
    else
        obj.start = undefined;
}

export function
UpdaterDto_to_json(j:object, obj:UpdaterDto) {
    j["name"] = obj.name;
    if( obj.refs !== undefined) {
        j["refs"] = obj.refs;
    }
    if( obj.args !== undefined) {
        j["args"] = obj.args;
    }
    if( obj.start !== undefined) {
        j["start"] = obj.start;
    }
}


class Updater extends UpdaterDto {

    _state : number;
    _nstates : number;
    title : string;

    constructor(
        name : string  = "",
        refs : number[]  = [],
        args : number[]  = [],
        start : number[]  = [],
        nstates : number  = 1,
        title : string  = "",
    ){
        super(
            name,
            refs,
            args,
            start,
        );
        this._state = -88;
        this._nstates = nstates;
        this.title = title;
    
    }

    GetStateNumber (
    ) : number  {
        
        if(this._state<0)
            throw new Error(`Updater ${this.name} has no state.`);
        return this._state;
        
    }

    GetStart (
    ) : number[]  {
        
        return this.start || [];
        
    }

    json (): string {
        return Updater_to_json_string(this);
    }
}
export function
Updater_equal (a: Updater, b: Updater) : boolean {
    if(!UpdaterDto_equal(a,b)) return false;
    return true;
}

export function
Updater_fromJSON (j:any, obj: Updater): void {
    UpdaterDto_fromJSON(j,obj)
}
export function
Updater_fromJSON_string (jstr:string): Updater {
    const j = JSON.parse(jstr);
    const obj = new Updater();
    Updater_fromJSON(j,obj);
    return obj;
}
export function
Updater_from_json_string (jstr:string): Updater {
    const j: object = JSON.parse(jstr);
    const obj: Updater = new Updater();
    Updater_from_json(j,obj);
    return obj;
}

export function
Updater_to_json_string (self:Updater) {
    const j = {};
    Updater_to_json(j,self);
    return JSON.stringify(j);
}

export function
Updater_from_json(j:object, obj:Updater) {
    UpdaterDto_from_json(j,obj);
}

export function
Updater_to_json(j:object, obj:Updater) {
    UpdaterDto_to_json(j,obj);
}



class BrownianMotion extends Updater {


    constructor(
        start : number  = Number.NaN,
        drift : number  = Number.NaN,
        diffusion : number  = Number.NaN,
        title : string  = "",
    ){
        super(
            "BrownianMotion",
            [],
            [drift,diffusion],
            [start],
            1,
            title,
        );
    
    }

    json (): string {
        return BrownianMotion_to_json_string(this);
    }
}
export function
BrownianMotion_equal (a: BrownianMotion, b: BrownianMotion) : boolean {
    if(!Updater_equal(a,b)) return false;
    return true;
}

export function
BrownianMotion_fromJSON (j:any, obj: BrownianMotion): void {
    Updater_fromJSON(j,obj)
}
export function
BrownianMotion_fromJSON_string (jstr:string): BrownianMotion {
    const j = JSON.parse(jstr);
    const obj = new BrownianMotion();
    BrownianMotion_fromJSON(j,obj);
    return obj;
}
export function
BrownianMotion_from_json_string (jstr:string): BrownianMotion {
    const j: object = JSON.parse(jstr);
    const obj: BrownianMotion = new BrownianMotion();
    BrownianMotion_from_json(j,obj);
    return obj;
}

export function
BrownianMotion_to_json_string (self:BrownianMotion) {
    const j = {};
    BrownianMotion_to_json(j,self);
    return JSON.stringify(j);
}

export function
BrownianMotion_from_json(j:object, obj:BrownianMotion) {
    Updater_from_json(j,obj);
}

export function
BrownianMotion_to_json(j:object, obj:BrownianMotion) {
    Updater_to_json(j,obj);
}


class BrownianMotionRef extends Updater {


    constructor(
        start : number  = Number.NaN,
        drift : number  = -88,
        diffusion : number  = -88,
        title : string  = "",
    ){
        super(
            "BrownianMotion",
            [drift,diffusion],
            [],
            [start],
            1,
            title,
        );
    
    }

    json (): string {
        return BrownianMotionRef_to_json_string(this);
    }
}
export function
BrownianMotionRef_equal (a: BrownianMotionRef, b: BrownianMotionRef) : boolean {
    if(!Updater_equal(a,b)) return false;
    return true;
}

export function
BrownianMotionRef_fromJSON (j:any, obj: BrownianMotionRef): void {
    Updater_fromJSON(j,obj)
}
export function
BrownianMotionRef_fromJSON_string (jstr:string): BrownianMotionRef {
    const j = JSON.parse(jstr);
    const obj = new BrownianMotionRef();
    BrownianMotionRef_fromJSON(j,obj);
    return obj;
}
export function
BrownianMotionRef_from_json_string (jstr:string): BrownianMotionRef {
    const j: object = JSON.parse(jstr);
    const obj: BrownianMotionRef = new BrownianMotionRef();
    BrownianMotionRef_from_json(j,obj);
    return obj;
}

export function
BrownianMotionRef_to_json_string (self:BrownianMotionRef) {
    const j = {};
    BrownianMotionRef_to_json(j,self);
    return JSON.stringify(j);
}

export function
BrownianMotionRef_from_json(j:object, obj:BrownianMotionRef) {
    Updater_from_json(j,obj);
}

export function
BrownianMotionRef_to_json(j:object, obj:BrownianMotionRef) {
    Updater_to_json(j,obj);
}


class GeometricalBrownianMotion extends Updater {


    constructor(
        start : number  = Number.NaN,
        drift : number  = Number.NaN,
        diffusion : number  = Number.NaN,
        title : string  = "",
    ){
        super(
            "GeometricalBrownianMotion",
            [],
            [drift,diffusion],
            [start],
            1,
            title,
        );
    
    }

    json (): string {
        return GeometricalBrownianMotion_to_json_string(this);
    }
}
export function
GeometricalBrownianMotion_equal (a: GeometricalBrownianMotion, b: GeometricalBrownianMotion) : boolean {
    if(!Updater_equal(a,b)) return false;
    return true;
}

export function
GeometricalBrownianMotion_fromJSON (j:any, obj: GeometricalBrownianMotion): void {
    Updater_fromJSON(j,obj)
}
export function
GeometricalBrownianMotion_fromJSON_string (jstr:string): GeometricalBrownianMotion {
    const j = JSON.parse(jstr);
    const obj = new GeometricalBrownianMotion();
    GeometricalBrownianMotion_fromJSON(j,obj);
    return obj;
}
export function
GeometricalBrownianMotion_from_json_string (jstr:string): GeometricalBrownianMotion {
    const j: object = JSON.parse(jstr);
    const obj: GeometricalBrownianMotion = new GeometricalBrownianMotion();
    GeometricalBrownianMotion_from_json(j,obj);
    return obj;
}

export function
GeometricalBrownianMotion_to_json_string (self:GeometricalBrownianMotion) {
    const j = {};
    GeometricalBrownianMotion_to_json(j,self);
    return JSON.stringify(j);
}

export function
GeometricalBrownianMotion_from_json(j:object, obj:GeometricalBrownianMotion) {
    Updater_from_json(j,obj);
}

export function
GeometricalBrownianMotion_to_json(j:object, obj:GeometricalBrownianMotion) {
    Updater_to_json(j,obj);
}


class GeometricalBrownianMotionRef extends Updater {


    constructor(
        start : number  = Number.NaN,
        drift : number  = -88,
        diffusion : number  = -88,
        title : string  = "",
    ){
        super(
            "GeometricalBrownianMotion",
            [drift,diffusion],
            [],
            [start],
            1,
            title,
        );
    
    }

    json (): string {
        return GeometricalBrownianMotionRef_to_json_string(this);
    }
}
export function
GeometricalBrownianMotionRef_equal (a: GeometricalBrownianMotionRef, b: GeometricalBrownianMotionRef) : boolean {
    if(!Updater_equal(a,b)) return false;
    return true;
}

export function
GeometricalBrownianMotionRef_fromJSON (j:any, obj: GeometricalBrownianMotionRef): void {
    Updater_fromJSON(j,obj)
}
export function
GeometricalBrownianMotionRef_fromJSON_string (jstr:string): GeometricalBrownianMotionRef {
    const j = JSON.parse(jstr);
    const obj = new GeometricalBrownianMotionRef();
    GeometricalBrownianMotionRef_fromJSON(j,obj);
    return obj;
}
export function
GeometricalBrownianMotionRef_from_json_string (jstr:string): GeometricalBrownianMotionRef {
    const j: object = JSON.parse(jstr);
    const obj: GeometricalBrownianMotionRef = new GeometricalBrownianMotionRef();
    GeometricalBrownianMotionRef_from_json(j,obj);
    return obj;
}

export function
GeometricalBrownianMotionRef_to_json_string (self:GeometricalBrownianMotionRef) {
    const j = {};
    GeometricalBrownianMotionRef_to_json(j,self);
    return JSON.stringify(j);
}

export function
GeometricalBrownianMotionRef_from_json(j:object, obj:GeometricalBrownianMotionRef) {
    Updater_from_json(j,obj);
}

export function
GeometricalBrownianMotionRef_to_json(j:object, obj:GeometricalBrownianMotionRef) {
    Updater_to_json(j,obj);
}


class ZeroCouponBond extends Updater {


    constructor(
        underlying : number  = -88,
        start : number  = Number.NaN,
        title : string  = "",
    ){
        super(
            "ZeroCouponBond",
            [underlying],
            [],
            [start],
            1,
            title,
        );
    
    }

    json (): string {
        return ZeroCouponBond_to_json_string(this);
    }
}
export function
ZeroCouponBond_equal (a: ZeroCouponBond, b: ZeroCouponBond) : boolean {
    if(!Updater_equal(a,b)) return false;
    return true;
}

export function
ZeroCouponBond_fromJSON (j:any, obj: ZeroCouponBond): void {
    Updater_fromJSON(j,obj)
}
export function
ZeroCouponBond_fromJSON_string (jstr:string): ZeroCouponBond {
    const j = JSON.parse(jstr);
    const obj = new ZeroCouponBond();
    ZeroCouponBond_fromJSON(j,obj);
    return obj;
}
export function
ZeroCouponBond_from_json_string (jstr:string): ZeroCouponBond {
    const j: object = JSON.parse(jstr);
    const obj: ZeroCouponBond = new ZeroCouponBond();
    ZeroCouponBond_from_json(j,obj);
    return obj;
}

export function
ZeroCouponBond_to_json_string (self:ZeroCouponBond) {
    const j = {};
    ZeroCouponBond_to_json(j,self);
    return JSON.stringify(j);
}

export function
ZeroCouponBond_from_json(j:object, obj:ZeroCouponBond) {
    Updater_from_json(j,obj);
}

export function
ZeroCouponBond_to_json(j:object, obj:ZeroCouponBond) {
    Updater_to_json(j,obj);
}


class Option extends Updater {

    Call : number = 0;
    Put : number = 1;

    constructor(
        underlying : number  = -88,
        strike : number  = Number.NaN,
        call_put : number  = -88,
        title : string  = "",
    ){
        super(
            "Option",
            [underlying],
            [strike,call_put],
            [],
            1,
            title,
        );
    
    }

    json (): string {
        return Option_to_json_string(this);
    }
}
export function
Option_equal (a: Option, b: Option) : boolean {
    if(!Updater_equal(a,b)) return false;
    return true;
}

export function
Option_fromJSON (j:any, obj: Option): void {
    Updater_fromJSON(j,obj)
}
export function
Option_fromJSON_string (jstr:string): Option {
    const j = JSON.parse(jstr);
    const obj = new Option();
    Option_fromJSON(j,obj);
    return obj;
}
export function
Option_from_json_string (jstr:string): Option {
    const j: object = JSON.parse(jstr);
    const obj: Option = new Option();
    Option_from_json(j,obj);
    return obj;
}

export function
Option_to_json_string (self:Option) {
    const j = {};
    Option_to_json(j,self);
    return JSON.stringify(j);
}

export function
Option_from_json(j:object, obj:Option) {
    Updater_from_json(j,obj);
}

export function
Option_to_json(j:object, obj:Option) {
    Updater_to_json(j,obj);
}


class Barrier extends Updater {

    DirectionUp : number = 1;
    DirectionDown : number = -1;
    DirectionAny : number = 0;
    ActionSet : number = 0;

    constructor(
        underlying : number  = -88,
        start : number  = Number.NaN,
        level : number  = Number.NaN,
        direction : number  = -88,
        action : number  = -88,
        value : number  = Number.NaN,
        title : string  = "",
    ){
        super(
            "Barrier",
            [underlying],
            [level,value,direction,action],
            [start],
            1,
            title,
        );
    
    }

    json (): string {
        return Barrier_to_json_string(this);
    }
}
export function
Barrier_equal (a: Barrier, b: Barrier) : boolean {
    if(!Updater_equal(a,b)) return false;
    return true;
}

export function
Barrier_fromJSON (j:any, obj: Barrier): void {
    Updater_fromJSON(j,obj)
}
export function
Barrier_fromJSON_string (jstr:string): Barrier {
    const j = JSON.parse(jstr);
    const obj = new Barrier();
    Barrier_fromJSON(j,obj);
    return obj;
}
export function
Barrier_from_json_string (jstr:string): Barrier {
    const j: object = JSON.parse(jstr);
    const obj: Barrier = new Barrier();
    Barrier_from_json(j,obj);
    return obj;
}

export function
Barrier_to_json_string (self:Barrier) {
    const j = {};
    Barrier_to_json(j,self);
    return JSON.stringify(j);
}

export function
Barrier_from_json(j:object, obj:Barrier) {
    Updater_from_json(j,obj);
}

export function
Barrier_to_json(j:object, obj:Barrier) {
    Updater_to_json(j,obj);
}


class Polynom extends Updater {


    constructor(
        ref : number  = -1,
        args : number[]  = [],
        title : string  = "",
    ){
        super(
            "Polynom",
            [ref],
            args,
            [],
            1,
            title,
        );
    
    }

    json (): string {
        return Polynom_to_json_string(this);
    }
}
export function
Polynom_equal (a: Polynom, b: Polynom) : boolean {
    if(!Updater_equal(a,b)) return false;
    return true;
}

export function
Polynom_fromJSON (j:any, obj: Polynom): void {
    Updater_fromJSON(j,obj)
}
export function
Polynom_fromJSON_string (jstr:string): Polynom {
    const j = JSON.parse(jstr);
    const obj = new Polynom();
    Polynom_fromJSON(j,obj);
    return obj;
}
export function
Polynom_from_json_string (jstr:string): Polynom {
    const j: object = JSON.parse(jstr);
    const obj: Polynom = new Polynom();
    Polynom_from_json(j,obj);
    return obj;
}

export function
Polynom_to_json_string (self:Polynom) {
    const j = {};
    Polynom_to_json(j,self);
    return JSON.stringify(j);
}

export function
Polynom_from_json(j:object, obj:Polynom) {
    Updater_from_json(j,obj);
}

export function
Polynom_to_json(j:object, obj:Polynom) {
    Updater_to_json(j,obj);
}


class Linear1DInterpolation extends Updater {


    constructor(
        ref : number  = -88,
        xmin : number  = -1,
        xmax : number  = 1,
        y : number[]  = [],
        title : string  = "",
    ){
        super(
            "Linear1DInterpolation",
            [ref],
            [],
            [],
            1,
            title,
        );
    
        
        if(y.length<2)
            throw new Error("Linear1DInterpolation: y-vector must have at least 2 elements: y(xmin), y(xmax)");
        this.args = [...[xmin,xmax],...y];
        
    }

    json (): string {
        return Linear1DInterpolation_to_json_string(this);
    }
}
export function
Linear1DInterpolation_equal (a: Linear1DInterpolation, b: Linear1DInterpolation) : boolean {
    if(!Updater_equal(a,b)) return false;
    return true;
}

export function
Linear1DInterpolation_fromJSON (j:any, obj: Linear1DInterpolation): void {
    Updater_fromJSON(j,obj)
}
export function
Linear1DInterpolation_fromJSON_string (jstr:string): Linear1DInterpolation {
    const j = JSON.parse(jstr);
    const obj = new Linear1DInterpolation();
    Linear1DInterpolation_fromJSON(j,obj);
    return obj;
}
export function
Linear1DInterpolation_from_json_string (jstr:string): Linear1DInterpolation {
    const j: object = JSON.parse(jstr);
    const obj: Linear1DInterpolation = new Linear1DInterpolation();
    Linear1DInterpolation_from_json(j,obj);
    return obj;
}

export function
Linear1DInterpolation_to_json_string (self:Linear1DInterpolation) {
    const j = {};
    Linear1DInterpolation_to_json(j,self);
    return JSON.stringify(j);
}

export function
Linear1DInterpolation_from_json(j:object, obj:Linear1DInterpolation) {
    Updater_from_json(j,obj);
}

export function
Linear1DInterpolation_to_json(j:object, obj:Linear1DInterpolation) {
    Updater_to_json(j,obj);
}


class Multiplication extends Updater {


    constructor(
        refs : number[]  = [],
        factor : number  = 1,
        title : string  = "",
    ){
        super(
            "Multiplication",
            refs,
            [factor],
            [],
            1,
            title,
        );
    
    }

    json (): string {
        return Multiplication_to_json_string(this);
    }
}
export function
Multiplication_equal (a: Multiplication, b: Multiplication) : boolean {
    if(!Updater_equal(a,b)) return false;
    return true;
}

export function
Multiplication_fromJSON (j:any, obj: Multiplication): void {
    Updater_fromJSON(j,obj)
}
export function
Multiplication_fromJSON_string (jstr:string): Multiplication {
    const j = JSON.parse(jstr);
    const obj = new Multiplication();
    Multiplication_fromJSON(j,obj);
    return obj;
}
export function
Multiplication_from_json_string (jstr:string): Multiplication {
    const j: object = JSON.parse(jstr);
    const obj: Multiplication = new Multiplication();
    Multiplication_from_json(j,obj);
    return obj;
}

export function
Multiplication_to_json_string (self:Multiplication) {
    const j = {};
    Multiplication_to_json(j,self);
    return JSON.stringify(j);
}

export function
Multiplication_from_json(j:object, obj:Multiplication) {
    Updater_from_json(j,obj);
}

export function
Multiplication_to_json(j:object, obj:Multiplication) {
    Updater_to_json(j,obj);
}


class Division extends Updater {


    constructor(
        numerator : number  = -88,
        denominator : number  = -88,
        eps : number  = 0,
        title : string  = "",
    ){
        super(
            "Division",
            [numerator,denominator],
            [eps],
            [],
            1,
            title,
        );
    
    }

    json (): string {
        return Division_to_json_string(this);
    }
}
export function
Division_equal (a: Division, b: Division) : boolean {
    if(!Updater_equal(a,b)) return false;
    return true;
}

export function
Division_fromJSON (j:any, obj: Division): void {
    Updater_fromJSON(j,obj)
}
export function
Division_fromJSON_string (jstr:string): Division {
    const j = JSON.parse(jstr);
    const obj = new Division();
    Division_fromJSON(j,obj);
    return obj;
}
export function
Division_from_json_string (jstr:string): Division {
    const j: object = JSON.parse(jstr);
    const obj: Division = new Division();
    Division_from_json(j,obj);
    return obj;
}

export function
Division_to_json_string (self:Division) {
    const j = {};
    Division_to_json(j,self);
    return JSON.stringify(j);
}

export function
Division_from_json(j:object, obj:Division) {
    Updater_from_json(j,obj);
}

export function
Division_to_json(j:object, obj:Division) {
    Updater_to_json(j,obj);
}


class HistogramAxis {

    state : number;
    nbins : number;
    min : number|undefined;
    max : number|undefined;
    title : string|undefined;

    constructor(
        state : number  = -88,
        nbins : number  = -88,
        min : number  = -88,
        max : number  = -88,
        title : string  = "",
    ){
        this.state = state;
        this.nbins = nbins;
        this.min = min;
        this.max = max;
        this.title = title;
    
    }

    json (): string {
        return HistogramAxis_to_json_string(this);
    }
}
export function
HistogramAxis_equal (a: HistogramAxis, b: HistogramAxis) : boolean {
    if(!int_equal(a.state,b.state)) return false;
    if(!int_equal(a.nbins,b.nbins)) return false;
    if(a.min===undefined && b.min!==undefined) return false;
    if(a.min!==undefined && b.min===undefined) return false;
    if(a.min!==undefined && b.min!==undefined)
    if(!float_equal(a.min!,b.min!)) return false;
    if(a.max===undefined && b.max!==undefined) return false;
    if(a.max!==undefined && b.max===undefined) return false;
    if(a.max!==undefined && b.max!==undefined)
    if(!float_equal(a.max!,b.max!)) return false;
    if(a.title===undefined && b.title!==undefined) return false;
    if(a.title!==undefined && b.title===undefined) return false;
    if(a.title!==undefined && b.title!==undefined)
    if(!string_equal(a.title!,b.title!)) return false;
    return true;
}

export function
HistogramAxis_fromJSON (j:any, obj: HistogramAxis): void {
    obj.state = j["state"];
    obj.nbins = j["nbins"];
    if("min" in j)
        obj.min = j["min"];
    if("max" in j)
        obj.max = j["max"];
    if("title" in j)
        obj.title = j["title"];
}
export function
HistogramAxis_fromJSON_string (jstr:string): HistogramAxis {
    const j = JSON.parse(jstr);
    const obj = new HistogramAxis();
    HistogramAxis_fromJSON(j,obj);
    return obj;
}
export function
HistogramAxis_from_json_string (jstr:string): HistogramAxis {
    const j: object = JSON.parse(jstr);
    const obj: HistogramAxis = new HistogramAxis();
    HistogramAxis_from_json(j,obj);
    return obj;
}

export function
HistogramAxis_to_json_string (self:HistogramAxis) {
    const j = {};
    HistogramAxis_to_json(j,self);
    return JSON.stringify(j);
}

export function
HistogramAxis_from_json(j:object, obj:HistogramAxis) {
    obj.state = j["state"];
    obj.nbins = j["nbins"];
    if("min" in j)
        obj.min = j["min"] as number|undefined;
    else
        obj.min = undefined;
    if("max" in j)
        obj.max = j["max"] as number|undefined;
    else
        obj.max = undefined;
    if("title" in j)
        obj.title = j["title"] as string|undefined;
    else
        obj.title = undefined;
}

export function
HistogramAxis_to_json(j:object, obj:HistogramAxis) {
    j["state"] = obj.state;
    j["nbins"] = obj.nbins;
    if( obj.min !== undefined) {
        j["min"] = obj.min;
    }
    if( obj.max !== undefined) {
        j["max"] = obj.max;
    }
    if( obj.title !== undefined) {
        j["title"] = obj.title;
    }
}


class Histogram {

    ax : HistogramAxis;
    ay : HistogramAxis|undefined;
    evaluation_point : number|undefined;
    bins : number[]|undefined;

    constructor(
        ax : HistogramAxis  = new HistogramAxis(),
        ay : HistogramAxis|undefined  = undefined,
        evaluation_point : number|undefined  = undefined,
        bins : number[]|undefined  = undefined,
    ){
        this.ax = ax;
        this.ay = ay;
        this.evaluation_point = evaluation_point;
        this.bins = bins;
    
    }

    json (): string {
        return Histogram_to_json_string(this);
    }
}
export function
Histogram_equal (a: Histogram, b: Histogram) : boolean {
    if(!HistogramAxis_equal(a.ax,b.ax)) return false;
    if(a.ay===undefined && b.ay!==undefined) return false;
    if(a.ay!==undefined && b.ay===undefined) return false;
    if(a.ay!==undefined && b.ay!==undefined)
    if(!HistogramAxis_equal(a.ay!,b.ay!)) return false;
    if(a.evaluation_point===undefined && b.evaluation_point!==undefined) return false;
    if(a.evaluation_point!==undefined && b.evaluation_point===undefined) return false;
    if(a.evaluation_point!==undefined && b.evaluation_point!==undefined)
    if(!int_equal(a.evaluation_point!,b.evaluation_point!)) return false;
    if(a.bins===undefined && b.bins!==undefined) return false;
    if(a.bins!==undefined && b.bins===undefined) return false;
    if(a.bins!==undefined && b.bins!==undefined)
        if(!list_equal(a.bins!,b.bins!,float_equal)) return false;
    return true;
}

export function
Histogram_fromJSON (j:any, obj: Histogram): void {
    obj.ax = j["ax"];
    if("ay" in j)
        obj.ay = j["ay"];
    if("evaluation_point" in j)
        obj.evaluation_point = j["evaluation_point"];
    if("bins" in j)
        obj.bins = j["bins"];
}
export function
Histogram_fromJSON_string (jstr:string): Histogram {
    const j = JSON.parse(jstr);
    const obj = new Histogram();
    Histogram_fromJSON(j,obj);
    return obj;
}
export function
Histogram_from_json_string (jstr:string): Histogram {
    const j: object = JSON.parse(jstr);
    const obj: Histogram = new Histogram();
    Histogram_from_json(j,obj);
    return obj;
}

export function
Histogram_to_json_string (self:Histogram) {
    const j = {};
    Histogram_to_json(j,self);
    return JSON.stringify(j);
}

export function
Histogram_from_json(j:object, obj:Histogram) {
    HistogramAxis_from_json(j["ax"],obj.ax);
    if( "ay" in j)
        obj.ay = j["ay"] as HistogramAxis|undefined;
    if("evaluation_point" in j)
        obj.evaluation_point = j["evaluation_point"] as number|undefined;
    else
        obj.evaluation_point = undefined;
    if("bins" in j)
        obj.bins = j["bins"] as number[]|undefined;
    else
        obj.bins = undefined;
}

export function
Histogram_to_json(j:object, obj:Histogram) {
    {
        const jj = {};
        HistogramAxis_to_json(jj,obj.ax);
        j["ax"] = jj;
    }
    if( obj.ay !== undefined) {
        {
            const jj = {};
            HistogramAxis_to_json(jj,obj.ay);
            j["ay"] = jj;
        }
    }
    if( obj.evaluation_point !== undefined) {
        j["evaluation_point"] = obj.evaluation_point;
    }
    if( obj.bins !== undefined) {
        j["bins"] = obj.bins;
    }
}



class Histogram2 {

    AxisX : HistogramAxis;
    AxisY : HistogramAxis|undefined;
    AxisZ : HistogramAxis|undefined;
    Flags : number|undefined;
    EvaluationPoint : number|undefined;
    TimeStep : number|undefined;
    Title : string|undefined;
    Bins : number[]|undefined;

    constructor(
        AxisX : HistogramAxis  = new HistogramAxis(),
        AxisY : HistogramAxis|undefined  = undefined,
        AxisZ : HistogramAxis|undefined  = undefined,
        Flags : number|undefined  = undefined,
        EvaluationPoint : number|undefined  = undefined,
        TimeStep : number|undefined  = undefined,
        Title : string|undefined  = undefined,
        Bins : number[]|undefined  = undefined,
    ){
        this.AxisX = AxisX;
        this.AxisY = AxisY;
        this.AxisZ = AxisZ;
        this.Flags = Flags;
        this.EvaluationPoint = EvaluationPoint;
        this.TimeStep = TimeStep;
        this.Title = Title;
        this.Bins = Bins;
    
    }

    json (): string {
        return Histogram2_to_json_string(this);
    }
}
export function
Histogram2_equal (a: Histogram2, b: Histogram2) : boolean {
    if(!HistogramAxis_equal(a.AxisX,b.AxisX)) return false;
    if(a.AxisY===undefined && b.AxisY!==undefined) return false;
    if(a.AxisY!==undefined && b.AxisY===undefined) return false;
    if(a.AxisY!==undefined && b.AxisY!==undefined)
    if(!HistogramAxis_equal(a.AxisY!,b.AxisY!)) return false;
    if(a.AxisZ===undefined && b.AxisZ!==undefined) return false;
    if(a.AxisZ!==undefined && b.AxisZ===undefined) return false;
    if(a.AxisZ!==undefined && b.AxisZ!==undefined)
    if(!HistogramAxis_equal(a.AxisZ!,b.AxisZ!)) return false;
    if(a.Flags===undefined && b.Flags!==undefined) return false;
    if(a.Flags!==undefined && b.Flags===undefined) return false;
    if(a.Flags!==undefined && b.Flags!==undefined)
    if(!int_equal(a.Flags!,b.Flags!)) return false;
    if(a.EvaluationPoint===undefined && b.EvaluationPoint!==undefined) return false;
    if(a.EvaluationPoint!==undefined && b.EvaluationPoint===undefined) return false;
    if(a.EvaluationPoint!==undefined && b.EvaluationPoint!==undefined)
    if(!int_equal(a.EvaluationPoint!,b.EvaluationPoint!)) return false;
    if(a.TimeStep===undefined && b.TimeStep!==undefined) return false;
    if(a.TimeStep!==undefined && b.TimeStep===undefined) return false;
    if(a.TimeStep!==undefined && b.TimeStep!==undefined)
    if(!int_equal(a.TimeStep!,b.TimeStep!)) return false;
    if(a.Title===undefined && b.Title!==undefined) return false;
    if(a.Title!==undefined && b.Title===undefined) return false;
    if(a.Title!==undefined && b.Title!==undefined)
    if(!string_equal(a.Title!,b.Title!)) return false;
    if(a.Bins===undefined && b.Bins!==undefined) return false;
    if(a.Bins!==undefined && b.Bins===undefined) return false;
    if(a.Bins!==undefined && b.Bins!==undefined)
        if(!list_equal(a.Bins!,b.Bins!,float_equal)) return false;
    return true;
}

export function
Histogram2_fromJSON (j:any, obj: Histogram2): void {
    obj.AxisX = j["AxisX"];
    if("AxisY" in j)
        obj.AxisY = j["AxisY"];
    if("AxisZ" in j)
        obj.AxisZ = j["AxisZ"];
    if("Flags" in j)
        obj.Flags = j["Flags"];
    if("EvaluationPoint" in j)
        obj.EvaluationPoint = j["EvaluationPoint"];
    if("TimeStep" in j)
        obj.TimeStep = j["TimeStep"];
    if("Title" in j)
        obj.Title = j["Title"];
    if("Bins" in j)
        obj.Bins = j["Bins"];
}
export function
Histogram2_fromJSON_string (jstr:string): Histogram2 {
    const j = JSON.parse(jstr);
    const obj = new Histogram2();
    Histogram2_fromJSON(j,obj);
    return obj;
}
export function
Histogram2_from_json_string (jstr:string): Histogram2 {
    const j: object = JSON.parse(jstr);
    const obj: Histogram2 = new Histogram2();
    Histogram2_from_json(j,obj);
    return obj;
}

export function
Histogram2_to_json_string (self:Histogram2) {
    const j = {};
    Histogram2_to_json(j,self);
    return JSON.stringify(j);
}

export function
Histogram2_from_json(j:object, obj:Histogram2) {
    HistogramAxis_from_json(j["AxisX"],obj.AxisX);
    if( "AxisY" in j)
        obj.AxisY = j["AxisY"] as HistogramAxis|undefined;
    if( "AxisZ" in j)
        obj.AxisZ = j["AxisZ"] as HistogramAxis|undefined;
    if("Flags" in j)
        obj.Flags = j["Flags"] as number|undefined;
    else
        obj.Flags = undefined;
    if("EvaluationPoint" in j)
        obj.EvaluationPoint = j["EvaluationPoint"] as number|undefined;
    else
        obj.EvaluationPoint = undefined;
    if("TimeStep" in j)
        obj.TimeStep = j["TimeStep"] as number|undefined;
    else
        obj.TimeStep = undefined;
    if("Title" in j)
        obj.Title = j["Title"] as string|undefined;
    else
        obj.Title = undefined;
    if("Bins" in j)
        obj.Bins = j["Bins"] as number[]|undefined;
    else
        obj.Bins = undefined;
}

export function
Histogram2_to_json(j:object, obj:Histogram2) {
    {
        const jj = {};
        HistogramAxis_to_json(jj,obj.AxisX);
        j["AxisX"] = jj;
    }
    if( obj.AxisY !== undefined) {
        {
            const jj = {};
            HistogramAxis_to_json(jj,obj.AxisY);
            j["AxisY"] = jj;
        }
    }
    if( obj.AxisZ !== undefined) {
        {
            const jj = {};
            HistogramAxis_to_json(jj,obj.AxisZ);
            j["AxisZ"] = jj;
        }
    }
    if( obj.Flags !== undefined) {
        j["Flags"] = obj.Flags;
    }
    if( obj.EvaluationPoint !== undefined) {
        j["EvaluationPoint"] = obj.EvaluationPoint;
    }
    if( obj.TimeStep !== undefined) {
        j["TimeStep"] = obj.TimeStep;
    }
    if( obj.Title !== undefined) {
        j["Title"] = obj.Title;
    }
    if( obj.Bins !== undefined) {
        j["Bins"] = obj.Bins;
    }
}



class EvaluationPoint {

    time : number;
    histograms : Histogram[]|undefined;

    constructor(
        time : number  = Number.NaN,
        histograms : Histogram[]|undefined  = undefined,
    ){
        this.time = time;
        this.histograms = histograms;
    
    }

    GetTime (
    ) : number  {
        
        return this.time;
        
    }

    Add (
        
        histogram : Histogram,
    ) : EvaluationPoint  {
        
        if(this.histograms === undefined)
            this.histograms = [];
        this.histograms.push(histogram);
        return this;
        
    }

    json (): string {
        return EvaluationPoint_to_json_string(this);
    }
}
export function
EvaluationPoint_equal (a: EvaluationPoint, b: EvaluationPoint) : boolean {
    if(!float_equal(a.time,b.time)) return false;
    if(a.histograms===undefined && b.histograms!==undefined) return false;
    if(a.histograms!==undefined && b.histograms===undefined) return false;
    if(a.histograms!==undefined && b.histograms!==undefined)
        if(!list_equal(a.histograms!,b.histograms!,Histogram_equal)) return false;
    return true;
}

export function
EvaluationPoint_fromJSON (j:any, obj: EvaluationPoint): void {
    obj.time = j["time"];
    if("histograms" in j)
        obj.histograms = j["histograms"];
}
export function
EvaluationPoint_fromJSON_string (jstr:string): EvaluationPoint {
    const j = JSON.parse(jstr);
    const obj = new EvaluationPoint();
    EvaluationPoint_fromJSON(j,obj);
    return obj;
}
export function
EvaluationPoint_from_json_string (jstr:string): EvaluationPoint {
    const j: object = JSON.parse(jstr);
    const obj: EvaluationPoint = new EvaluationPoint();
    EvaluationPoint_from_json(j,obj);
    return obj;
}

export function
EvaluationPoint_to_json_string (self:EvaluationPoint) {
    const j = {};
    EvaluationPoint_to_json(j,self);
    return JSON.stringify(j);
}

export function
EvaluationPoint_from_json(j:object, obj:EvaluationPoint) {
    obj.time = j["time"];
    if( "histograms" in j)
        obj.histograms = j["histograms"] as Histogram[]|undefined;
}

export function
EvaluationPoint_to_json(j:object, obj:EvaluationPoint) {
    j["time"] = obj.time;
    if( obj.histograms !== undefined) {
        j["histograms"] = [];
        for(let item of obj.histograms) {
            const jj = {};
            Histogram_to_json(jj,item);
            j["histograms"].push(jj);
        }
    }
}


class Model {

    version : string = "Model:1";
    TimeStart : number;
    TimeSteps : number;
    NumPaths : number;
    updaters : Updater[];
    evaluations : EvaluationPoint[];
    RandomSeed : number|undefined;
    RunTimeoutSeconds : number|undefined;
    titles : {[key:number]: string};
    _nstates : number;

    constructor(
        TimeStart : number  = Number.NaN,
        TimeSteps : number  = 0,
        NumPaths : number  = 0,
        updaters : Updater[]  = [],
        evaluations : EvaluationPoint[]  = [],
        RandomSeed : number|undefined  = undefined,
        RunTimeoutSeconds : number|undefined  = undefined,
        nstates : number  = 0,
    ){
        this.TimeStart = TimeStart;
        this.TimeSteps = TimeSteps;
        this.NumPaths = NumPaths;
        this.updaters = updaters;
        this.evaluations = evaluations;
        this.RandomSeed = RandomSeed;
        this.RunTimeoutSeconds = RunTimeoutSeconds;
        this._nstates = nstates;
    
        
        this.titles = {};
        
    }

    GetNumberOfUpdaters (
    ) : number  {
        
        return this.updaters.length;
        
    }

    GetNumberOfStates (
    ) : number  {
        
        return this._nstates;
        
    }

    Add (
        
        updater : Updater,
    ) : Updater  {
        
        updater._state = this._nstates;
        this._nstates += updater._nstates;
        this.updaters.push(updater);
        this.titles[updater._state] = updater.title;
        return updater;
        
    }

    json (): string {
        return Model_to_json_string(this);
    }
}
export function
Model_equal (a: Model, b: Model) : boolean {
    if(!string_equal(a.version,b.version)) return false;
    if(!float_equal(a.TimeStart,b.TimeStart)) return false;
    if(!int_equal(a.TimeSteps,b.TimeSteps)) return false;
    if(!int_equal(a.NumPaths,b.NumPaths)) return false;
    if(!list_equal(a.updaters,b.updaters,Updater_equal)) return false;
    if(!list_equal(a.evaluations,b.evaluations,EvaluationPoint_equal)) return false;
    if(a.RandomSeed===undefined && b.RandomSeed!==undefined) return false;
    if(a.RandomSeed!==undefined && b.RandomSeed===undefined) return false;
    if(a.RandomSeed!==undefined && b.RandomSeed!==undefined)
    if(!int_equal(a.RandomSeed!,b.RandomSeed!)) return false;
    if(a.RunTimeoutSeconds===undefined && b.RunTimeoutSeconds!==undefined) return false;
    if(a.RunTimeoutSeconds!==undefined && b.RunTimeoutSeconds===undefined) return false;
    if(a.RunTimeoutSeconds!==undefined && b.RunTimeoutSeconds!==undefined)
    if(!float_equal(a.RunTimeoutSeconds!,b.RunTimeoutSeconds!)) return false;
    return true;
}

export function
Model_fromJSON (j:any, obj: Model): void {
    obj.version = j["version"];
    obj.TimeStart = j["TimeStart"];
    obj.TimeSteps = j["TimeSteps"];
    obj.NumPaths = j["NumPaths"];
    obj.updaters = j["updaters"];
    obj.evaluations = j["evaluations"];
    if("RandomSeed" in j)
        obj.RandomSeed = j["RandomSeed"];
    if("RunTimeoutSeconds" in j)
        obj.RunTimeoutSeconds = j["RunTimeoutSeconds"];
}
export function
Model_fromJSON_string (jstr:string): Model {
    const j = JSON.parse(jstr);
    const obj = new Model();
    Model_fromJSON(j,obj);
    return obj;
}
export function
Model_from_json_string (jstr:string): Model {
    const j: object = JSON.parse(jstr);
    const obj: Model = new Model();
    Model_from_json(j,obj);
    return obj;
}

export function
Model_to_json_string (self:Model) {
    const j = {};
    Model_to_json(j,self);
    return JSON.stringify(j);
}

export function
Model_from_json(j:object, obj:Model) {
    obj.version = j["version"];
    obj.TimeStart = j["TimeStart"];
    obj.TimeSteps = j["TimeSteps"];
    obj.NumPaths = j["NumPaths"];
    for(let item of j["updaters"]) {
        const v: Updater = new Updater();
        Updater_from_json(item,v);
        obj.updaters.push(v);
    }
    for(let item of j["evaluations"]) {
        const v: EvaluationPoint = new EvaluationPoint();
        EvaluationPoint_from_json(item,v);
        obj.evaluations.push(v);
    }
    if("RandomSeed" in j)
        obj.RandomSeed = j["RandomSeed"] as number|undefined;
    else
        obj.RandomSeed = undefined;
    if("RunTimeoutSeconds" in j)
        obj.RunTimeoutSeconds = j["RunTimeoutSeconds"] as number|undefined;
    else
        obj.RunTimeoutSeconds = undefined;
}

export function
Model_to_json(j:object, obj:Model) {
    j["version"] = obj.version;
    j["TimeStart"] = obj.TimeStart;
    j["TimeSteps"] = obj.TimeSteps;
    j["NumPaths"] = obj.NumPaths;
    j["updaters"] = [];
    for(let item of obj.updaters) {
        const jj = {};
        Updater_to_json(jj,item);
        j["updaters"].push(jj);
    }
    j["evaluations"] = [];
    for(let item of obj.evaluations) {
        const jj = {};
        EvaluationPoint_to_json(jj,item);
        j["evaluations"].push(jj);
    }
    if( obj.RandomSeed !== undefined) {
        j["RandomSeed"] = obj.RandomSeed;
    }
    if( obj.RunTimeoutSeconds !== undefined) {
        j["RunTimeoutSeconds"] = obj.RunTimeoutSeconds;
    }
}


class Result {

    n : number;
    mean : number;
    stddev : number;
    skewness : number;

    constructor(
        n : number  = 0,
        mean : number  = Number.NaN,
        stddev : number  = Number.NaN,
        skewness : number  = Number.NaN,
    ){
        this.n = n;
        this.mean = mean;
        this.stddev = stddev;
        this.skewness = skewness;
    
    }

    GetMean (
    ) : number  {
        
        return this.mean;
        
    }

    GetMeanError (
    ) : number  {
        
        return this.n<=0 ? Number.NaN : this.stddev/Math.sqrt(this.n);
        
    }

    GetStdDev (
    ) : number  {
        
        return this.stddev;
        
    }

    GetSkewness (
    ) : number  {
        
        return this.skewness;
        
    }

    json (): string {
        return Result_to_json_string(this);
    }
}
export function
Result_equal (a: Result, b: Result) : boolean {
    if(!int_equal(a.n,b.n)) return false;
    if(!float_equal(a.mean,b.mean)) return false;
    if(!float_equal(a.stddev,b.stddev)) return false;
    if(!float_equal(a.skewness,b.skewness)) return false;
    return true;
}

export function
Result_fromJSON (j:any, obj: Result): void {
    obj.n = j["n"];
    obj.mean = j["mean"];
    obj.stddev = j["stddev"];
    obj.skewness = j["skewness"];
}
export function
Result_fromJSON_string (jstr:string): Result {
    const j = JSON.parse(jstr);
    const obj = new Result();
    Result_fromJSON(j,obj);
    return obj;
}
export function
Result_from_json_string (jstr:string): Result {
    const j: object = JSON.parse(jstr);
    const obj: Result = new Result();
    Result_from_json(j,obj);
    return obj;
}

export function
Result_to_json_string (self:Result) {
    const j = {};
    Result_to_json(j,self);
    return JSON.stringify(j);
}

export function
Result_from_json(j:object, obj:Result) {
    obj.n = j["n"];
    obj.mean = j["mean"];
    obj.stddev = j["stddev"];
    obj.skewness = j["skewness"];
}

export function
Result_to_json(j:object, obj:Result) {
    j["n"] = obj.n;
    j["mean"] = obj.mean;
    j["stddev"] = obj.stddev;
    j["skewness"] = obj.skewness;
}


class EvaluationResults {

    names : string[];
    npaths : number[];
    mean : number[];
    stddev : number[];
    skewness : number[];
    time_points : number[];
    time_steps : number[];
    histograms : Histogram[];
    histograms2 : Histogram2[];
    model : Model|undefined;

    constructor(
        names : string[]  = [],
        npaths : number[]  = [],
        mean : number[]  = [],
        stddev : number[]  = [],
        skewness : number[]  = [],
        time_points : number[]  = [],
        time_steps : number[]  = [],
        histograms : Histogram[]  = [],
        histograms2 : Histogram2[]  = [],
        model : Model|undefined  = undefined,
    ){
        this.names = names;
        this.npaths = npaths;
        this.mean = mean;
        this.stddev = stddev;
        this.skewness = skewness;
        this.time_points = time_points;
        this.time_steps = time_steps;
        this.histograms = histograms;
        this.histograms2 = histograms2;
        this.model = model;
    
    }

    GetNumberOfStates (
    ) : number  {
        
        return this.names.length;
        
    }

    GetNumberOfEvaluations (
    ) : number  {
        
        return this.time_points.length;
        
    }

    Index (
        
        state : number,
        
        point : number,
    ) : number  {
        
        if( !(state>=0 && state<this.GetNumberOfStates() && point>=0 && point<this.GetNumberOfEvaluations()))
            throw new Error(`Index`);
        return point*this.GetNumberOfStates() + state;
        
    }

    GetStateEvaluationResult (
        
        state : number,
        
        point : number,
    ) : Result  {
        
        const n = this.Index(state,point);
        return new Result(this.npaths[n],this.mean[n],this.stddev[n],this.skewness[n]);
        
    }

    json (): string {
        return EvaluationResults_to_json_string(this);
    }
}
export function
EvaluationResults_equal (a: EvaluationResults, b: EvaluationResults) : boolean {
    if(!list_equal(a.names,b.names,string_equal)) return false;
    if(!list_equal(a.npaths,b.npaths,int_equal)) return false;
    if(!list_equal(a.mean,b.mean,float_equal)) return false;
    if(!list_equal(a.stddev,b.stddev,float_equal)) return false;
    if(!list_equal(a.skewness,b.skewness,float_equal)) return false;
    if(!list_equal(a.time_points,b.time_points,float_equal)) return false;
    if(!list_equal(a.time_steps,b.time_steps,int_equal)) return false;
    if(!list_equal(a.histograms,b.histograms,Histogram_equal)) return false;
    if(!list_equal(a.histograms2,b.histograms2,Histogram2_equal)) return false;
    if(a.model===undefined && b.model!==undefined) return false;
    if(a.model!==undefined && b.model===undefined) return false;
    if(a.model!==undefined && b.model!==undefined)
    if(!Model_equal(a.model!,b.model!)) return false;
    return true;
}

export function
EvaluationResults_fromJSON (j:any, obj: EvaluationResults): void {
    obj.names = j["names"];
    obj.npaths = j["npaths"];
    obj.mean = j["mean"];
    obj.stddev = j["stddev"];
    obj.skewness = j["skewness"];
    obj.time_points = j["time_points"];
    obj.time_steps = j["time_steps"];
    obj.histograms = j["histograms"];
    obj.histograms2 = j["histograms2"];
    if("model" in j)
        obj.model = j["model"];
}
export function
EvaluationResults_fromJSON_string (jstr:string): EvaluationResults {
    const j = JSON.parse(jstr);
    const obj = new EvaluationResults();
    EvaluationResults_fromJSON(j,obj);
    return obj;
}
export function
EvaluationResults_from_json_string (jstr:string): EvaluationResults {
    const j: object = JSON.parse(jstr);
    const obj: EvaluationResults = new EvaluationResults();
    EvaluationResults_from_json(j,obj);
    return obj;
}

export function
EvaluationResults_to_json_string (self:EvaluationResults) {
    const j = {};
    EvaluationResults_to_json(j,self);
    return JSON.stringify(j);
}

export function
EvaluationResults_from_json(j:object, obj:EvaluationResults) {
    obj.names = j["names"];
    obj.npaths = j["npaths"];
    obj.mean = j["mean"];
    obj.stddev = j["stddev"];
    obj.skewness = j["skewness"];
    obj.time_points = j["time_points"];
    obj.time_steps = j["time_steps"];
    for(let item of j["histograms"]) {
        const v: Histogram = new Histogram();
        Histogram_from_json(item,v);
        obj.histograms.push(v);
    }
    for(let item of j["histograms2"]) {
        const v: Histogram2 = new Histogram2();
        Histogram2_from_json(item,v);
        obj.histograms2.push(v);
    }
    if( "model" in j)
        obj.model = j["model"] as Model|undefined;
}

export function
EvaluationResults_to_json(j:object, obj:EvaluationResults) {
    j["names"] = obj.names;
    j["npaths"] = obj.npaths;
    j["mean"] = obj.mean;
    j["stddev"] = obj.stddev;
    j["skewness"] = obj.skewness;
    j["time_points"] = obj.time_points;
    j["time_steps"] = obj.time_steps;
    j["histograms"] = [];
    for(let item of obj.histograms) {
        const jj = {};
        Histogram_to_json(jj,item);
        j["histograms"].push(jj);
    }
    j["histograms2"] = [];
    for(let item of obj.histograms2) {
        const jj = {};
        Histogram2_to_json(jj,item);
        j["histograms2"].push(jj);
    }
    if( obj.model !== undefined) {
        {
            const jj = {};
            Model_to_json(jj,obj.model);
            j["model"] = jj;
        }
    }
}



class Sum extends Updater {


    constructor(
        weights : number[]  = [],
        states : number[]  = [],
        title : string  = "",
    ){
        super(
            "Sum",
            states,
            weights,
            [],
            1,
            title,
        );
    
    }

    json (): string {
        return Sum_to_json_string(this);
    }
}
export function
Sum_equal (a: Sum, b: Sum) : boolean {
    if(!Updater_equal(a,b)) return false;
    return true;
}

export function
Sum_fromJSON (j:any, obj: Sum): void {
    Updater_fromJSON(j,obj)
}
export function
Sum_fromJSON_string (jstr:string): Sum {
    const j = JSON.parse(jstr);
    const obj = new Sum();
    Sum_fromJSON(j,obj);
    return obj;
}
export function
Sum_from_json_string (jstr:string): Sum {
    const j: object = JSON.parse(jstr);
    const obj: Sum = new Sum();
    Sum_from_json(j,obj);
    return obj;
}

export function
Sum_to_json_string (self:Sum) {
    const j = {};
    Sum_to_json(j,self);
    return JSON.stringify(j);
}

export function
Sum_from_json(j:object, obj:Sum) {
    Updater_from_json(j,obj);
}

export function
Sum_to_json(j:object, obj:Sum) {
    Updater_to_json(j,obj);
}


class SumOfFutureValues extends Updater {


    constructor(
        state : number  = -88,
        t : number[]  = [],
        title : string  = "",
    ){
        super(
            "SumOfFutureValues",
            [state],
            t,
            [],
            1,
            title,
        );
    
    }

    json (): string {
        return SumOfFutureValues_to_json_string(this);
    }
}
export function
SumOfFutureValues_equal (a: SumOfFutureValues, b: SumOfFutureValues) : boolean {
    if(!Updater_equal(a,b)) return false;
    return true;
}

export function
SumOfFutureValues_fromJSON (j:any, obj: SumOfFutureValues): void {
    Updater_fromJSON(j,obj)
}
export function
SumOfFutureValues_fromJSON_string (jstr:string): SumOfFutureValues {
    const j = JSON.parse(jstr);
    const obj = new SumOfFutureValues();
    SumOfFutureValues_fromJSON(j,obj);
    return obj;
}
export function
SumOfFutureValues_from_json_string (jstr:string): SumOfFutureValues {
    const j: object = JSON.parse(jstr);
    const obj: SumOfFutureValues = new SumOfFutureValues();
    SumOfFutureValues_from_json(j,obj);
    return obj;
}

export function
SumOfFutureValues_to_json_string (self:SumOfFutureValues) {
    const j = {};
    SumOfFutureValues_to_json(j,self);
    return JSON.stringify(j);
}

export function
SumOfFutureValues_from_json(j:object, obj:SumOfFutureValues) {
    Updater_from_json(j,obj);
}

export function
SumOfFutureValues_to_json(j:object, obj:SumOfFutureValues) {
    Updater_to_json(j,obj);
}


////////////////////////////////////////////////////////////////
// The start of "include.ts"
////////////////////////////////////////////////////////////////
import fetch from "node-fetch"

export async function run (model:Model, server:string) {
    return fetch(
        `${server}/model`,
        {
            method: 'post',
            body: JSON.stringify(model)
        }
    ).then(async result => {
        const json = await result.json();
        return json;
    })
}
////////////////////////////////////////////////////////////////
// The end of "include.ts"
////////////////////////////////////////////////////////////////

export {
    Error,
    UpdaterDoc,
    UpdaterDto,
    Updater,
    BrownianMotion,
    BrownianMotionRef,
    GeometricalBrownianMotion,
    GeometricalBrownianMotionRef,
    ZeroCouponBond,
    Option,
    Barrier,
    Polynom,
    Linear1DInterpolation,
    Multiplication,
    Division,
    HistogramAxis,
    Histogram,
    Histogram2,
    EvaluationPoint,
    Model,
    Result,
    EvaluationResults,
    Sum,
    SumOfFutureValues,
}
