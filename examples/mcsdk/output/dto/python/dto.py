# 
# https://github.com/AlexanderZvyagin/dto-code-generator
# Generated by CODE GENERATOR OF DATA TRANSFER OBJECTS (cgdto) version 0.8.0
# 
# Generated from schema: MonteCarlo SDK version (0.6.4-dev-versioning)
# 

from __future__ import annotations
from copy import deepcopy
import math
from math import nan
import json
try:
    import pandas as pd
except:
    print('Warning: "pandas" package was not found.')

def float_equal(a:float|None, b:float|None) -> bool:
    if a is None and b is None: return True
    if a is None and b is not None: return False
    if b is None and a is not None: return False
    if math.isnan(a) and math.isnan(b): return True
    eps = 1e-9
    ab_diff = abs(a-b)
    if ab_diff<eps: return True
    ab_ratio = ab_diff/(abs(a/2 + b/2) + eps)
    if ab_ratio<eps: return True
    return False


# Forward declaration
class Error: pass
class Error:

    
    def __init__ (
        self,
        message:str|None = None,
        details:str|None = None,
        code:int|None = None,
        errors:list[Error]|None = None
    ):
        self.message : str|None = message
        self.details : str|None = details
        self.code : int|None = code
        self.errors : list[Error]|None = deepcopy(errors)
        pass

    def __eq__ (self, other):
        if self.message != other.message: return False
        if self.details != other.details: return False
        if self.code != other.code: return False
        if self.errors != other.errors: return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return Error_to_json_string(self)
def Error_from_json_string (jstr):
    j = json.loads(jstr)
    obj = Error()
    Error_from_json(j,obj)
    return obj

def Error_to_json_string (self:Error):
    j = {}
    Error_to_json(j,self)
    return json.dumps(j)
def Error_from_json (j:dict, obj:Error):
    assert isinstance(obj,Error)
    if j.get("message",None) is not None:
        obj.message = j["message"]
    if j.get("details",None) is not None:
        obj.details = j["details"]
    if j.get("code",None) is not None:
        obj.code = j["code"]
    if j.get("errors",None) is not None:
        obj.errors = []
        for item in j["errors"]:
            v = Error()
            Error_from_json(item,v)
            obj.errors.append(v)
def Error_to_json(j:dict, obj:Error):
    if obj.message is not None:
        j["message"] = obj.message
    if obj.details is not None:
        j["details"] = obj.details
    if obj.code is not None:
        j["code"] = obj.code
    if obj.errors is not None:
        j["errors"] = []
        for item in obj.errors:
            jj = {}
            Error_to_json(jj,item)
            j["errors"].append(jj)
    pass

# Forward declaration
class UpdaterDoc: pass
class UpdaterDoc:

    
    def __init__ (
        self,
        name:str = "",
        title:str = "",
        doc_md:str = "",
        start:str = "",
        nargs_min:int = -88,
        nrefs_min:int = -88
    ):
        self.version : int = 1
        #: The parameter 'name' is a single world which uniquely identifies how a MC state will be updated.
        #: E.g. GeometricalBrownianMotion.
        self.name : str = name
        #: Short description (single line) what the updater is doing.
        self.title : str = title
        #: Long multiline description of the updater using Markdown format.
        self.doc_md : str = doc_md
        self.start : str = start
        self.nargs_min : int = nargs_min
        self.nrefs_min : int = nrefs_min
        pass

    def __eq__ (self, other):
        if self.version != other.version: return False
        if self.name != other.name: return False
        if self.title != other.title: return False
        if self.doc_md != other.doc_md: return False
        if self.start != other.start: return False
        if self.nargs_min != other.nargs_min: return False
        if self.nrefs_min != other.nrefs_min: return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return UpdaterDoc_to_json_string(self)
def UpdaterDoc_from_json_string (jstr):
    j = json.loads(jstr)
    obj = UpdaterDoc()
    UpdaterDoc_from_json(j,obj)
    return obj

def UpdaterDoc_to_json_string (self:UpdaterDoc):
    j = {}
    UpdaterDoc_to_json(j,self)
    return json.dumps(j)
def UpdaterDoc_from_json (j:dict, obj:UpdaterDoc):
    assert isinstance(obj,UpdaterDoc)
    obj.version = j["version"]
    obj.name = j["name"]
    obj.title = j["title"]
    obj.doc_md = j["doc_md"]
    obj.start = j["start"]
    obj.nargs_min = j["nargs_min"]
    obj.nrefs_min = j["nrefs_min"]
def UpdaterDoc_to_json(j:dict, obj:UpdaterDoc):
    j["version"] = obj.version
    j["name"] = obj.name
    j["title"] = obj.title
    j["doc_md"] = obj.doc_md
    j["start"] = obj.start
    j["nargs_min"] = obj.nargs_min
    j["nrefs_min"] = obj.nrefs_min
    pass

# Forward declaration
class UpdaterDto: pass
class UpdaterDto:


    '''

UpdaterDto is used to pass parameters to update a state.
'''

    
    def __init__ (
        self,
        name:str = "",
        refs:list[int]|None = None,
        args:list[float]|None = None,
        start:list[float]|None = None
    ):
        self.name : str = name
        self.refs : list[int]|None = refs
        self.args : list[float]|None = args
        self.start : list[float]|None = start
        pass

    def __eq__ (self, other):
        if self.name != other.name: return False
        if self.refs != other.refs: return False
        if self.args != other.args: return False
        if self.start != other.start: return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return UpdaterDto_to_json_string(self)
def UpdaterDto_from_json_string (jstr):
    j = json.loads(jstr)
    obj = UpdaterDto()
    UpdaterDto_from_json(j,obj)
    return obj

def UpdaterDto_to_json_string (self:UpdaterDto):
    j = {}
    UpdaterDto_to_json(j,self)
    return json.dumps(j)
def UpdaterDto_from_json (j:dict, obj:UpdaterDto):
    assert isinstance(obj,UpdaterDto)
    obj.name = j["name"]
    if j.get("refs",None) is not None:
        obj.refs = j["refs"]
    if j.get("args",None) is not None:
        obj.args = j["args"]
    if j.get("start",None) is not None:
        obj.start = j["start"]
def UpdaterDto_to_json(j:dict, obj:UpdaterDto):
    j["name"] = obj.name
    if obj.refs is not None:
        j["refs"] = obj.refs
    if obj.args is not None:
        j["args"] = obj.args
    if obj.start is not None:
        j["start"] = obj.start
    pass

# Forward declaration
class Updater: pass
class Updater (UpdaterDto):

    
    def __init__ (
        self,
        name:str = "",
        refs:list[int] = [],
        args:list[float] = [],
        start:list[float] = [],
        nstates:int = 1,
        title:str = ""
    ):
        super().__init__(
            name,
            refs,
            args,
            start,
        )
        self._state : int = -88
        self._nstates : int = nstates
        self.title : str = title
        pass

    def __repr__ (
        self,
    ) -> str :
        
        if self._nstates==0:
            state='None'
        elif self._nstates==1:
            state=f'{self._state}'
        else:
            states=f'[{self._state}...{self._state+self._nstates-1}]'
        refs = str(self.refs)
        args = str(self.args)
        return f'{self.name} nstates={self._nstates} state={self._state} refs={self.refs} args={self.args} start={self.start}'
        
        pass

    def GetStateNumber (
        self,
    ) -> int :
        
        if self._state<0:
            raise Exception(f'Updater {self.name} has no state.')
        return self._state
        
        pass

    def GetStart (
        self,
    ) -> list[float] :
        
        return []   if self.start is None else   self.start
        
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return Updater_to_json_string(self)
def Updater_from_json_string (jstr):
    j = json.loads(jstr)
    obj = Updater()
    Updater_from_json(j,obj)
    return obj

def Updater_to_json_string (self:Updater):
    j = {}
    Updater_to_json(j,self)
    return json.dumps(j)
def Updater_from_json (j:dict, obj:Updater):
    assert isinstance(obj,Updater)
    UpdaterDto_from_json(j,obj)
def Updater_to_json(j:dict, obj:Updater):
    UpdaterDto_to_json(j,obj)
    pass


# Forward declaration
class IndependentGaussian: pass
class IndependentGaussian (Updater):

    
    def __init__ (
        self,
        refs:list[int] = [],
        title:str = ""
    ):
        super().__init__(
            "IndependentGaussian",
            refs,
            [],
            [],
            0,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return IndependentGaussian_to_json_string(self)
def IndependentGaussian_from_json_string (jstr):
    j = json.loads(jstr)
    obj = IndependentGaussian()
    IndependentGaussian_from_json(j,obj)
    return obj

def IndependentGaussian_to_json_string (self:IndependentGaussian):
    j = {}
    IndependentGaussian_to_json(j,self)
    return json.dumps(j)
def IndependentGaussian_from_json (j:dict, obj:IndependentGaussian):
    assert isinstance(obj,IndependentGaussian)
    Updater_from_json(j,obj)
def IndependentGaussian_to_json(j:dict, obj:IndependentGaussian):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class CorrelatedGaussian: pass
class CorrelatedGaussian (Updater):

    
    def __init__ (
        self,
        correlation:float = nan,
        state1:int = -88,
        state2:int = -88,
        title:str = ""
    ):
        super().__init__(
            "CorrelatedGaussian",
            [state1,state2],
            [correlation],
            [],
            0,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return CorrelatedGaussian_to_json_string(self)
def CorrelatedGaussian_from_json_string (jstr):
    j = json.loads(jstr)
    obj = CorrelatedGaussian()
    CorrelatedGaussian_from_json(j,obj)
    return obj

def CorrelatedGaussian_to_json_string (self:CorrelatedGaussian):
    j = {}
    CorrelatedGaussian_to_json(j,self)
    return json.dumps(j)
def CorrelatedGaussian_from_json (j:dict, obj:CorrelatedGaussian):
    assert isinstance(obj,CorrelatedGaussian)
    Updater_from_json(j,obj)
def CorrelatedGaussian_to_json(j:dict, obj:CorrelatedGaussian):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class BrownianMotion: pass
class BrownianMotion (Updater):

    
    def __init__ (
        self,
        start:float = nan,
        drift:float = nan,
        diffusion:float = nan,
        title:str = ""
    ):
        super().__init__(
            "BrownianMotion",
            [],
            [drift,diffusion],
            [start],
            1,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return BrownianMotion_to_json_string(self)
def BrownianMotion_from_json_string (jstr):
    j = json.loads(jstr)
    obj = BrownianMotion()
    BrownianMotion_from_json(j,obj)
    return obj

def BrownianMotion_to_json_string (self:BrownianMotion):
    j = {}
    BrownianMotion_to_json(j,self)
    return json.dumps(j)
def BrownianMotion_from_json (j:dict, obj:BrownianMotion):
    assert isinstance(obj,BrownianMotion)
    Updater_from_json(j,obj)
def BrownianMotion_to_json(j:dict, obj:BrownianMotion):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class BrownianMotionRef: pass
class BrownianMotionRef (Updater):

    
    def __init__ (
        self,
        start:float = nan,
        drift:int = -88,
        diffusion:int = -88,
        title:str = ""
    ):
        super().__init__(
            "BrownianMotion",
            [drift,diffusion],
            [],
            [start],
            1,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return BrownianMotionRef_to_json_string(self)
def BrownianMotionRef_from_json_string (jstr):
    j = json.loads(jstr)
    obj = BrownianMotionRef()
    BrownianMotionRef_from_json(j,obj)
    return obj

def BrownianMotionRef_to_json_string (self:BrownianMotionRef):
    j = {}
    BrownianMotionRef_to_json(j,self)
    return json.dumps(j)
def BrownianMotionRef_from_json (j:dict, obj:BrownianMotionRef):
    assert isinstance(obj,BrownianMotionRef)
    Updater_from_json(j,obj)
def BrownianMotionRef_to_json(j:dict, obj:BrownianMotionRef):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class GeometricalBrownianMotion: pass
class GeometricalBrownianMotion (Updater):

    
    def __init__ (
        self,
        start:float = nan,
        drift:float = nan,
        diffusion:float = nan,
        title:str = ""
    ):
        super().__init__(
            "GeometricalBrownianMotion",
            [],
            [drift,diffusion],
            [start],
            1,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return GeometricalBrownianMotion_to_json_string(self)
def GeometricalBrownianMotion_from_json_string (jstr):
    j = json.loads(jstr)
    obj = GeometricalBrownianMotion()
    GeometricalBrownianMotion_from_json(j,obj)
    return obj

def GeometricalBrownianMotion_to_json_string (self:GeometricalBrownianMotion):
    j = {}
    GeometricalBrownianMotion_to_json(j,self)
    return json.dumps(j)
def GeometricalBrownianMotion_from_json (j:dict, obj:GeometricalBrownianMotion):
    assert isinstance(obj,GeometricalBrownianMotion)
    Updater_from_json(j,obj)
def GeometricalBrownianMotion_to_json(j:dict, obj:GeometricalBrownianMotion):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class GeometricalBrownianMotionRef: pass
class GeometricalBrownianMotionRef (Updater):

    
    def __init__ (
        self,
        start:float = nan,
        drift:int = -88,
        diffusion:int = -88,
        title:str = ""
    ):
        super().__init__(
            "GeometricalBrownianMotion",
            [drift,diffusion],
            [],
            [start],
            1,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return GeometricalBrownianMotionRef_to_json_string(self)
def GeometricalBrownianMotionRef_from_json_string (jstr):
    j = json.loads(jstr)
    obj = GeometricalBrownianMotionRef()
    GeometricalBrownianMotionRef_from_json(j,obj)
    return obj

def GeometricalBrownianMotionRef_to_json_string (self:GeometricalBrownianMotionRef):
    j = {}
    GeometricalBrownianMotionRef_to_json(j,self)
    return json.dumps(j)
def GeometricalBrownianMotionRef_from_json (j:dict, obj:GeometricalBrownianMotionRef):
    assert isinstance(obj,GeometricalBrownianMotionRef)
    Updater_from_json(j,obj)
def GeometricalBrownianMotionRef_to_json(j:dict, obj:GeometricalBrownianMotionRef):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class ZeroCouponBond: pass
class ZeroCouponBond (Updater):

    
    def __init__ (
        self,
        underlying:int = -88,
        start:float = nan,
        title:str = ""
    ):
        super().__init__(
            "ZeroCouponBond",
            [underlying],
            [],
            [start],
            1,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return ZeroCouponBond_to_json_string(self)
def ZeroCouponBond_from_json_string (jstr):
    j = json.loads(jstr)
    obj = ZeroCouponBond()
    ZeroCouponBond_from_json(j,obj)
    return obj

def ZeroCouponBond_to_json_string (self:ZeroCouponBond):
    j = {}
    ZeroCouponBond_to_json(j,self)
    return json.dumps(j)
def ZeroCouponBond_from_json (j:dict, obj:ZeroCouponBond):
    assert isinstance(obj,ZeroCouponBond)
    Updater_from_json(j,obj)
def ZeroCouponBond_to_json(j:dict, obj:ZeroCouponBond):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class Option: pass
class Option (Updater):

    
    def __init__ (
        self,
        underlying:int = -88,
        strike:float = nan,
        call_put:int = -88,
        title:str = ""
    ):
        self.Call : int = 0
        self.Put : int = 1
        super().__init__(
            "Option",
            [underlying],
            [strike,call_put],
            [],
            1,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return Option_to_json_string(self)
def Option_from_json_string (jstr):
    j = json.loads(jstr)
    obj = Option()
    Option_from_json(j,obj)
    return obj

def Option_to_json_string (self:Option):
    j = {}
    Option_to_json(j,self)
    return json.dumps(j)
def Option_from_json (j:dict, obj:Option):
    assert isinstance(obj,Option)
    Updater_from_json(j,obj)
def Option_to_json(j:dict, obj:Option):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class Barrier: pass
class Barrier (Updater):

    
    def __init__ (
        self,
        underlying:int = -88,
        start:float = nan,
        level:float = nan,
        direction:int = -88,
        action:int = -88,
        value:float = nan,
        title:str = ""
    ):
        self.DirectionUp : int = 1
        self.DirectionDown : int = -1
        self.DirectionAny : int = 0
        self.ActionSet : int = 0
        super().__init__(
            "Barrier",
            [underlying],
            [level,value,direction,action],
            [start],
            1,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return Barrier_to_json_string(self)
def Barrier_from_json_string (jstr):
    j = json.loads(jstr)
    obj = Barrier()
    Barrier_from_json(j,obj)
    return obj

def Barrier_to_json_string (self:Barrier):
    j = {}
    Barrier_to_json(j,self)
    return json.dumps(j)
def Barrier_from_json (j:dict, obj:Barrier):
    assert isinstance(obj,Barrier)
    Updater_from_json(j,obj)
def Barrier_to_json(j:dict, obj:Barrier):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class Polynom: pass
class Polynom (Updater):

    
    def __init__ (
        self,
        ref:int = -1,
        args:list[float] = [],
        title:str = ""
    ):
        super().__init__(
            "Polynom",
            [ref],
            args,
            [],
            1,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return Polynom_to_json_string(self)
def Polynom_from_json_string (jstr):
    j = json.loads(jstr)
    obj = Polynom()
    Polynom_from_json(j,obj)
    return obj

def Polynom_to_json_string (self:Polynom):
    j = {}
    Polynom_to_json(j,self)
    return json.dumps(j)
def Polynom_from_json (j:dict, obj:Polynom):
    assert isinstance(obj,Polynom)
    Updater_from_json(j,obj)
def Polynom_to_json(j:dict, obj:Polynom):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class Linear1DInterpolation: pass
class Linear1DInterpolation (Updater):

    
    def __init__ (
        self,
        ref:int = -88,
        xmin:float = -1,
        xmax:float = 1,
        y:list[float] = [],
        title:str = ""
    ):
        super().__init__(
            "Linear1DInterpolation",
            [ref],
            [],
            [],
            1,
            title,
        )
        
        if len(y)<2:
            raise ValueError("Linear1DInterpolation: y-vector must have at least 2 elements: y(xmin), y(xmax)")
        self.args = [xmin,xmax] + y
        
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return Linear1DInterpolation_to_json_string(self)
def Linear1DInterpolation_from_json_string (jstr):
    j = json.loads(jstr)
    obj = Linear1DInterpolation()
    Linear1DInterpolation_from_json(j,obj)
    return obj

def Linear1DInterpolation_to_json_string (self:Linear1DInterpolation):
    j = {}
    Linear1DInterpolation_to_json(j,self)
    return json.dumps(j)
def Linear1DInterpolation_from_json (j:dict, obj:Linear1DInterpolation):
    assert isinstance(obj,Linear1DInterpolation)
    Updater_from_json(j,obj)
def Linear1DInterpolation_to_json(j:dict, obj:Linear1DInterpolation):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class Multiplication: pass
class Multiplication (Updater):

    
    def __init__ (
        self,
        refs:list[int] = [],
        factor:float = 1,
        title:str = ""
    ):
        super().__init__(
            "Multiplication",
            refs,
            [factor],
            [],
            1,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return Multiplication_to_json_string(self)
def Multiplication_from_json_string (jstr):
    j = json.loads(jstr)
    obj = Multiplication()
    Multiplication_from_json(j,obj)
    return obj

def Multiplication_to_json_string (self:Multiplication):
    j = {}
    Multiplication_to_json(j,self)
    return json.dumps(j)
def Multiplication_from_json (j:dict, obj:Multiplication):
    assert isinstance(obj,Multiplication)
    Updater_from_json(j,obj)
def Multiplication_to_json(j:dict, obj:Multiplication):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class Division: pass
class Division (Updater):

    
    def __init__ (
        self,
        numerator:int = -88,
        denominator:int = -88,
        eps:float = 0,
        title:str = ""
    ):
        super().__init__(
            "Division",
            [numerator,denominator],
            [eps],
            [],
            1,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return Division_to_json_string(self)
def Division_from_json_string (jstr):
    j = json.loads(jstr)
    obj = Division()
    Division_from_json(j,obj)
    return obj

def Division_to_json_string (self:Division):
    j = {}
    Division_to_json(j,self)
    return json.dumps(j)
def Division_from_json (j:dict, obj:Division):
    assert isinstance(obj,Division)
    Updater_from_json(j,obj)
def Division_to_json(j:dict, obj:Division):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class HistogramAxis: pass
class HistogramAxis:

    
    def __init__ (
        self,
        state:int = -88,
        nbins:int = -88,
        min:float = -88,
        max:float = -88
    ):
        self.state : int = state
        self.nbins : int = nbins
        self.min : float = min
        self.max : float = max
        pass

    def __eq__ (self, other):
        if self.state != other.state: return False
        if self.nbins != other.nbins: return False
        if self.min != other.min: return False
        if self.max != other.max: return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return HistogramAxis_to_json_string(self)
def HistogramAxis_from_json_string (jstr):
    j = json.loads(jstr)
    obj = HistogramAxis()
    HistogramAxis_from_json(j,obj)
    return obj

def HistogramAxis_to_json_string (self:HistogramAxis):
    j = {}
    HistogramAxis_to_json(j,self)
    return json.dumps(j)
def HistogramAxis_from_json (j:dict, obj:HistogramAxis):
    assert isinstance(obj,HistogramAxis)
    obj.state = j["state"]
    obj.nbins = j["nbins"]
    obj.min = j["min"]
    obj.max = j["max"]
def HistogramAxis_to_json(j:dict, obj:HistogramAxis):
    j["state"] = obj.state
    j["nbins"] = obj.nbins
    j["min"] = obj.min
    j["max"] = obj.max
    pass

# Forward declaration
class Histogram: pass
class Histogram:

    
    def __init__ (
        self,
        ax:HistogramAxis = HistogramAxis(),
        ay:HistogramAxis|None = None,
        evaluation_point:int|None = None,
        bins:list[float]|None = None
    ):
        self.ax : HistogramAxis = deepcopy(ax)
        self.ay : HistogramAxis|None = deepcopy(ay)
        self.evaluation_point : int|None = evaluation_point
        self.bins : list[float]|None = bins
        pass

    def __eq__ (self, other):
        if self.ax != other.ax: return False
        if self.ay != other.ay: return False
        if self.evaluation_point != other.evaluation_point: return False
        if self.bins != other.bins: return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return Histogram_to_json_string(self)
def Histogram_from_json_string (jstr):
    j = json.loads(jstr)
    obj = Histogram()
    Histogram_from_json(j,obj)
    return obj

def Histogram_to_json_string (self:Histogram):
    j = {}
    Histogram_to_json(j,self)
    return json.dumps(j)
def Histogram_from_json (j:dict, obj:Histogram):
    assert isinstance(obj,Histogram)
    HistogramAxis_from_json(j["ax"],obj.ax)
    if j.get("ay",None) is not None:
        obj.ay = HistogramAxis()
        HistogramAxis_from_json(j["ay"],obj.ay)
    if j.get("evaluation_point",None) is not None:
        obj.evaluation_point = j["evaluation_point"]
    if j.get("bins",None) is not None:
        obj.bins = j["bins"]
def Histogram_to_json(j:dict, obj:Histogram):
    jj = {}
    HistogramAxis_to_json(jj,obj.ax)
    j["ax"] = jj
    if obj.ay is not None:
        jj = {}
        HistogramAxis_to_json(jj,obj.ay)
        j["ay"] = jj
    if obj.evaluation_point is not None:
        j["evaluation_point"] = obj.evaluation_point
    if obj.bins is not None:
        j["bins"] = obj.bins
    pass


# Forward declaration
class EvaluationPoint: pass
class EvaluationPoint:

    
    def __init__ (
        self,
        time:float = nan,
        histograms:list[Histogram]|None = None
    ):
        self.time : float = time
        self.histograms : list[Histogram]|None = deepcopy(histograms)
        pass

    def GetTime (
        self,
    ) -> int :
        
        return self.time
        
        pass

    def Add (
        self,
        histogram,
    ) -> EvaluationPoint :
        
        if getattr(self,'histograms',None) is None:
            self.histograms = []
        self.histograms.append(histogram)
        return self
        
        pass

    def __eq__ (self, other):
        if self.time != other.time: return False
        if self.histograms != other.histograms: return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return EvaluationPoint_to_json_string(self)
def EvaluationPoint_from_json_string (jstr):
    j = json.loads(jstr)
    obj = EvaluationPoint()
    EvaluationPoint_from_json(j,obj)
    return obj

def EvaluationPoint_to_json_string (self:EvaluationPoint):
    j = {}
    EvaluationPoint_to_json(j,self)
    return json.dumps(j)
def EvaluationPoint_from_json (j:dict, obj:EvaluationPoint):
    assert isinstance(obj,EvaluationPoint)
    obj.time = j["time"]
    if j.get("histograms",None) is not None:
        obj.histograms = []
        for item in j["histograms"]:
            v = Histogram()
            Histogram_from_json(item,v)
            obj.histograms.append(v)
def EvaluationPoint_to_json(j:dict, obj:EvaluationPoint):
    j["time"] = obj.time
    if obj.histograms is not None:
        j["histograms"] = []
        for item in obj.histograms:
            jj = {}
            Histogram_to_json(jj,item)
            j["histograms"].append(jj)
    pass

# Forward declaration
class Model: pass
class Model:

    
    def __init__ (
        self,
        TimeStart:float = nan,
        TimeSteps:int = 0,
        NumPaths:int = 0,
        updaters:list[Updater] = [],
        evaluations:list[EvaluationPoint] = [],
        RandomSeed:int|None = None,
        RunTimeoutSeconds:float|None = None,
        MemoryLimitKB:int|None = None,
        nstates:int = 0
    ):
        self.TimeStart : float = TimeStart
        self.TimeSteps : int = TimeSteps
        self.NumPaths : int = NumPaths
        self.updaters : list[Updater] = deepcopy(updaters)
        self.evaluations : list[EvaluationPoint] = deepcopy(evaluations)
        self.RandomSeed : int|None = RandomSeed
        self.RunTimeoutSeconds : float|None = RunTimeoutSeconds
        self.MemoryLimitKB : int|None = MemoryLimitKB
        self._nstates : int = nstates
        
        self.titles = {}
        
        pass

    def __repr__ (
        self,
    ) -> str :
        
        return f'TimeStart={self.TimeStart} TimeSteps={self.TimeSteps} NumPaths={self.NumPaths} updaters={len(self.updaters)}'
        
        pass

    def GetNumberOfUpdaters (
        self,
    ) -> int :
        
        return len(self.updaters)
        
        pass

    def GetNumberOfStates (
        self,
    ) -> int :
        
        return self._nstates
        
        pass

    def Add (
        self,
        updater,
    ) -> Updater :
        
        updater._state = self._nstates
        self._nstates += updater._nstates
        self.updaters.append(updater)
        self.titles[updater._state] = updater.title
        return updater
        
        pass

    def __eq__ (self, other):
        if self.TimeStart != other.TimeStart: return False
        if self.TimeSteps != other.TimeSteps: return False
        if self.NumPaths != other.NumPaths: return False
        if self.updaters != other.updaters: return False
        if self.evaluations != other.evaluations: return False
        if self.RandomSeed != other.RandomSeed: return False
        if self.RunTimeoutSeconds != other.RunTimeoutSeconds: return False
        if self.MemoryLimitKB != other.MemoryLimitKB: return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return Model_to_json_string(self)
def Model_from_json_string (jstr):
    j = json.loads(jstr)
    obj = Model()
    Model_from_json(j,obj)
    return obj

def Model_to_json_string (self:Model):
    j = {}
    Model_to_json(j,self)
    return json.dumps(j)
def Model_from_json (j:dict, obj:Model):
    assert isinstance(obj,Model)
    obj.TimeStart = j["TimeStart"]
    obj.TimeSteps = j["TimeSteps"]
    obj.NumPaths = j["NumPaths"]
    obj.updaters = []
    for item in j["updaters"]:
        v = Updater()
        Updater_from_json(item,v)
        obj.updaters.append(v)
    obj.evaluations = []
    for item in j["evaluations"]:
        v = EvaluationPoint()
        EvaluationPoint_from_json(item,v)
        obj.evaluations.append(v)
    if j.get("RandomSeed",None) is not None:
        obj.RandomSeed = j["RandomSeed"]
    if j.get("RunTimeoutSeconds",None) is not None:
        obj.RunTimeoutSeconds = j["RunTimeoutSeconds"]
    if j.get("MemoryLimitKB",None) is not None:
        obj.MemoryLimitKB = j["MemoryLimitKB"]
def Model_to_json(j:dict, obj:Model):
    j["TimeStart"] = obj.TimeStart
    j["TimeSteps"] = obj.TimeSteps
    j["NumPaths"] = obj.NumPaths
    j["updaters"] = []
    for item in obj.updaters:
        jj = {}
        Updater_to_json(jj,item)
        j["updaters"].append(jj)
    j["evaluations"] = []
    for item in obj.evaluations:
        jj = {}
        EvaluationPoint_to_json(jj,item)
        j["evaluations"].append(jj)
    if obj.RandomSeed is not None:
        j["RandomSeed"] = obj.RandomSeed
    if obj.RunTimeoutSeconds is not None:
        j["RunTimeoutSeconds"] = obj.RunTimeoutSeconds
    if obj.MemoryLimitKB is not None:
        j["MemoryLimitKB"] = obj.MemoryLimitKB
    pass

# Forward declaration
class Result: pass
class Result:

    
    def __init__ (
        self,
        n:int = 0,
        mean:float = nan,
        stddev:float = nan,
        skewness:float = nan
    ):
        self.n : int = n
        self.mean : float = mean
        self.stddev : float = stddev
        self.skewness : float = skewness
        pass

    def GetMean (
        self,
    ) -> float :
        
        return self.mean
        
        pass

    def GetMeanError (
        self,
    ) -> float :
    
        '''
    The function computes an error estimate of the mean value.
    '''
    
        
        return nan if self.n<=0 else self.stddev/math.sqrt(self.n)
        
        pass

    def GetStdDev (
        self,
    ) -> float :
        
        return self.stddev
        
        pass

    def GetSkewness (
        self,
    ) -> float :
        
        return self.skewness
        
        pass

    def __eq__ (self, other):
        if self.n != other.n: return False
        if self.mean != other.mean: return False
        if self.stddev != other.stddev: return False
        if self.skewness != other.skewness: return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return Result_to_json_string(self)
def Result_from_json_string (jstr):
    j = json.loads(jstr)
    obj = Result()
    Result_from_json(j,obj)
    return obj

def Result_to_json_string (self:Result):
    j = {}
    Result_to_json(j,self)
    return json.dumps(j)
def Result_from_json (j:dict, obj:Result):
    assert isinstance(obj,Result)
    obj.n = j["n"]
    obj.mean = j["mean"]
    obj.stddev = j["stddev"]
    obj.skewness = j["skewness"]
def Result_to_json(j:dict, obj:Result):
    j["n"] = obj.n
    j["mean"] = obj.mean
    j["stddev"] = obj.stddev
    j["skewness"] = obj.skewness
    pass

# Forward declaration
class EvaluationResults: pass
class EvaluationResults:

    
    def __init__ (
        self,
        names:list[str] = [],
        npaths:list[int] = [],
        mean:list[float] = [],
        stddev:list[float] = [],
        skewness:list[float] = [],
        time_points:list[float] = [],
        time_steps:list[int] = [],
        histograms:list[Histogram] = [],
        model:Model|None = None
    ):
        self.names : list[str] = names
        self.npaths : list[int] = npaths
        self.mean : list[float] = mean
        self.stddev : list[float] = stddev
        self.skewness : list[float] = skewness
        self.time_points : list[float] = time_points
        self.time_steps : list[int] = time_steps
        self.histograms : list[Histogram] = deepcopy(histograms)
        self.model : Model|None = deepcopy(model)
        pass

    def GetNumberOfStates (
        self,
    ) -> int :
        
        return len(self.names)
        
        pass

    def GetNumberOfEvaluations (
        self,
    ) -> int :
        
        return len(self.time_points)
        
        pass

    def Index (
        self,
        state,
        point,
    ) -> int :
        
        if not (state>=0 and state<self.GetNumberOfStates() and point>=0 and point<self.GetNumberOfEvaluations()):
            raise ValueError()
        return point*self.GetNumberOfStates() + state
        
        pass

    def GetStateEvaluationResult (
        self,
        state,
        point,
    ) -> Result :
        
        n = self.Index(state,point)
        return Result(self.npaths[n],self.mean[n],self.stddev[n],self.skewness[n])
        
        pass

    def df (
        self,
    ) -> any :
        
        data = []
        for j in range(self.GetNumberOfEvaluations()):
            for i in range(self.GetNumberOfStates()):
                n = self.Index(i,j)
                item = {
                    'name': self.names[i],
                    'title': '',
                    'state': i,
                    'point': j,
                    'time': self.time_points[j],
                    'step': self.time_steps[j],
                    'npaths': self.npaths[n],
                    'mean':self.mean[n],
                    'mean_error': None if (self.stddev[n] is None or self.npaths[n]<=0) else self.stddev[n]/math.sqrt(self.npaths[n]),
                    'stddev': self.stddev[n],
                    'skewness': self.skewness[n]
                }
                if self.model:
                    item['title'] = self.model.titles.get(i,'')
                data.append(item)
        return pd.DataFrame(data)
        
        pass

    def __eq__ (self, other):
        if self.names != other.names: return False
        if self.npaths != other.npaths: return False
        if self.mean != other.mean: return False
        if self.stddev != other.stddev: return False
        if self.skewness != other.skewness: return False
        if self.time_points != other.time_points: return False
        if self.time_steps != other.time_steps: return False
        if self.histograms != other.histograms: return False
        if self.model != other.model: return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return EvaluationResults_to_json_string(self)
def EvaluationResults_from_json_string (jstr):
    j = json.loads(jstr)
    obj = EvaluationResults()
    EvaluationResults_from_json(j,obj)
    return obj

def EvaluationResults_to_json_string (self:EvaluationResults):
    j = {}
    EvaluationResults_to_json(j,self)
    return json.dumps(j)
def EvaluationResults_from_json (j:dict, obj:EvaluationResults):
    assert isinstance(obj,EvaluationResults)
    obj.names = j["names"]
    obj.npaths = j["npaths"]
    obj.mean = j["mean"]
    obj.stddev = j["stddev"]
    obj.skewness = j["skewness"]
    obj.time_points = j["time_points"]
    obj.time_steps = j["time_steps"]
    obj.histograms = []
    for item in j["histograms"]:
        v = Histogram()
        Histogram_from_json(item,v)
        obj.histograms.append(v)
    if j.get("model",None) is not None:
        obj.model = Model()
        Model_from_json(j["model"],obj.model)
def EvaluationResults_to_json(j:dict, obj:EvaluationResults):
    j["names"] = obj.names
    j["npaths"] = obj.npaths
    j["mean"] = obj.mean
    j["stddev"] = obj.stddev
    j["skewness"] = obj.skewness
    j["time_points"] = obj.time_points
    j["time_steps"] = obj.time_steps
    j["histograms"] = []
    for item in obj.histograms:
        jj = {}
        Histogram_to_json(jj,item)
        j["histograms"].append(jj)
    if obj.model is not None:
        jj = {}
        Model_to_json(jj,obj.model)
        j["model"] = jj
    pass


def EvaluationResults_from_response(r,model=None):
    er = EvaluationResults_from_json_string(r.text)
    er.model = model
    return er


# Forward declaration
class Sum: pass
class Sum (Updater):

    
    def __init__ (
        self,
        weights:list[float] = [],
        states:list[int] = [],
        title:str = ""
    ):
        super().__init__(
            "Sum",
            states,
            weights,
            [],
            1,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return Sum_to_json_string(self)
def Sum_from_json_string (jstr):
    j = json.loads(jstr)
    obj = Sum()
    Sum_from_json(j,obj)
    return obj

def Sum_to_json_string (self:Sum):
    j = {}
    Sum_to_json(j,self)
    return json.dumps(j)
def Sum_from_json (j:dict, obj:Sum):
    assert isinstance(obj,Sum)
    Updater_from_json(j,obj)
def Sum_to_json(j:dict, obj:Sum):
    Updater_to_json(j,obj)
    pass

# Forward declaration
class SumOfFutureValues: pass
class SumOfFutureValues (Updater):

    
    def __init__ (
        self,
        state:int = -88,
        t:list[float] = [],
        title:str = ""
    ):
        super().__init__(
            "SumOfFutureValues",
            [state],
            t,
            [],
            1,
            title,
        )
        pass

    def __eq__ (self, other):
        if not super().__eq__(other): return False
        return True
    def __neq__ (self, other):
        return not self==other
    def json (self) -> str:
        return SumOfFutureValues_to_json_string(self)
def SumOfFutureValues_from_json_string (jstr):
    j = json.loads(jstr)
    obj = SumOfFutureValues()
    SumOfFutureValues_from_json(j,obj)
    return obj

def SumOfFutureValues_to_json_string (self:SumOfFutureValues):
    j = {}
    SumOfFutureValues_to_json(j,self)
    return json.dumps(j)
def SumOfFutureValues_from_json (j:dict, obj:SumOfFutureValues):
    assert isinstance(obj,SumOfFutureValues)
    Updater_from_json(j,obj)
def SumOfFutureValues_to_json(j:dict, obj:SumOfFutureValues):
    Updater_to_json(j,obj)
    pass

################################
# The start of "include.py"
################################
import requests

class SdkException (Exception):
    def __init__ (self,error:Error):
        super().__init__(error.message)
        self.error = error
    def __str__ (self):
        return f'{self.error.message}'
    
def run (model:Model, server:str) -> EvaluationResults:
    response = requests.post(f'{server}/model',Model_to_json_string(model))
    if response.status_code == 200:
        result = EvaluationResults_from_json_string(response.text)
        result.model = model
        return result
    else:
        error = Error_from_json_string(response.text)
        raise SdkException (error)
################################
# The end of "include.py"
################################

