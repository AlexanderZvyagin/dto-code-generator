#pragma once
// 
// https://github.com/AlexanderZvyagin/dto-code-generator
// Generated by CODE GENERATOR OF DATA TRANSFER OBJECTS (cgdto) version 0.8.2
// 
// Generated from schema: MonteCarlo SDK version (0.7.0)
// 


#include <optional>
#include <string>
#include <vector>
#include <map>
#include <stdexcept>
#include <cmath>

#include <nlohmann/json.hpp>
using json = nlohmann::json;


namespace dto {
class HistogramAxis;
std::string HistogramAxis_to_json_string(const HistogramAxis &obj);
class HistogramAxis {
public:

    int state;
    int nbins;
    std::optional<float> min;
    std::optional<float> max;
    std::optional<std::string> title;

    
    HistogramAxis (
        int state = -88,
        int nbins = -88,
        float min = -88,
        float max = -88,
        std::string title = ""
    )
    : state (
        state
    )
    , nbins (
        nbins
    )
    , min (
        min
    )
    , max (
        max
    )
    , title (
        title
    )
    {
    }

    bool operator == (const HistogramAxis &other) const {
        if (state != other.state) return false;
        if (nbins != other.nbins) return false;
        if (min != other.min) return false;
        if (max != other.max) return false;
        if (title != other.title) return false;
        return true;
    }
    bool operator != (const HistogramAxis &other) const {return not(*this==other);}
    std::string json (void) const {
        return HistogramAxis_to_json_string(*this);
    }
}; // HistogramAxis
inline
void to_json(json &j, const HistogramAxis &obj) try {
    j = json::object();
    j["state"] = obj.state;
    j["nbins"] = obj.nbins;
    if(obj.min.has_value())
        j["min"] = obj.min.value();
    if(obj.max.has_value())
        j["max"] = obj.max.value();
    if(obj.title.has_value())
        j["title"] = obj.title.value();
} catch (const std::exception &e) {
    std::throw_with_nested(std::runtime_error("void to_json(json &j, const HistogramAxis &obj) exception"));
}

inline
std::string HistogramAxis_to_json_string(const HistogramAxis &obj) {
    json j;
    to_json(j,obj);
    return j.dump();
}
inline
void from_json(const json &j, HistogramAxis &obj) try {
    j.at("state").get_to(obj.state);
    j.at("nbins").get_to(obj.nbins);
    if(auto it=j.find("min"); it!=j.end() and !it->is_null())
        obj.min = *it;
    if(auto it=j.find("max"); it!=j.end() and !it->is_null())
        obj.max = *it;
    if(auto it=j.find("title"); it!=j.end() and !it->is_null())
        obj.title = *it;
} catch (const std::exception &e) {
    std::throw_with_nested(std::runtime_error("void from_json(const json &j, HistogramAxis &obj) exception"));
}
inline
HistogramAxis HistogramAxis_from_json(const json &j) {
    HistogramAxis obj;
    from_json(j,obj);
    return obj;
}
} // namespace dto

