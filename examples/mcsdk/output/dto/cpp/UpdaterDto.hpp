#pragma once
// 
// https://github.com/AlexanderZvyagin/dto-code-generator
// Generated by CODE GENERATOR OF DATA TRANSFER OBJECTS (cgdto) version 0.6.4
// 
// Generated from schema: MonteCarlo SDK version (0.2.1)
// 


#include <optional>
#include <string>
#include <vector>
#include <map>
#include <stdexcept>
#include <cmath>

#include <nlohmann/json.hpp>
using json = nlohmann::json;


namespace dto {
class UpdaterDto;
std::string UpdaterDto_to_json_string(const UpdaterDto &obj);
class UpdaterDto {
public:

    std::string name;
    std::optional<std::vector<int>> refs;
    std::optional<std::vector<float>> args;
    std::optional<float> start;

    
    UpdaterDto (
        std::string name = "",
        std::optional<std::vector<int>> refs = {},
        std::optional<std::vector<float>> args = {},
        std::optional<float> start = {}
    )
    : name (
        name
    )
    , refs (
        refs
    )
    , args (
        args
    )
    , start (
        start
    )
    {
    }

    bool operator == (const UpdaterDto &other) const {
        if (name != other.name) return false;
        if (refs != other.refs) return false;
        if (args != other.args) return false;
        if (start != other.start) return false;
        return true;
    }
    bool operator != (const UpdaterDto &other) const {return not(*this==other);}
    std::string json (void) const {
        return UpdaterDto_to_json_string(*this);
    }
}; // UpdaterDto
inline
void to_json(json &j, const UpdaterDto &obj) try {
    j = json::object();
    j["name"] = obj.name;
    if(obj.refs.has_value())
        j["refs"] = obj.refs.value();
    if(obj.args.has_value())
        j["args"] = obj.args.value();
    if(obj.start.has_value())
        j["start"] = obj.start.value();
} catch (const std::exception &e) {
    std::throw_with_nested(std::runtime_error("void to_json(json &j, const UpdaterDto &obj) exception"));
}

inline
std::string UpdaterDto_to_json_string(const UpdaterDto &obj) {
    json j;
    to_json(j,obj);
    return j.dump();
}
inline
void from_json(const json &j, UpdaterDto &obj) try {
    j.at("name").get_to(obj.name);
    if(auto it=j.find("refs"); it!=j.end() and !it->is_null())
        obj.refs = *it;
    if(auto it=j.find("args"); it!=j.end() and !it->is_null())
        obj.args = *it;
    if(auto it=j.find("start"); it!=j.end() and !it->is_null())
        obj.start = *it;
} catch (const std::exception &e) {
    std::throw_with_nested(std::runtime_error("void from_json(const json &j, UpdaterDto &obj) exception"));
}
inline
UpdaterDto UpdaterDto_from_json(const json &j) {
    UpdaterDto obj;
    from_json(j,obj);
    return obj;
}
} // namespace dto

