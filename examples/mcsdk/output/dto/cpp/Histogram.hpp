#pragma once
// 
// https://github.com/AlexanderZvyagin/dto-code-generator
// Generated by CODE GENERATOR OF DATA TRANSFER OBJECTS (cgdto) version 0.6.3
// 
// Generated from schema: MonteCarlo SDK version (0.2.0)
// 


#include <optional>
#include <string>
#include <vector>
#include <map>
#include <stdexcept>
#include <cmath>

#include <nlohmann/json.hpp>
using json = nlohmann::json;


#include "HistogramAxis.hpp"
namespace dto {
class Histogram;
std::string Histogram_to_json_string(const Histogram &obj);
class Histogram {
public:

    HistogramAxis x;
    std::optional<HistogramAxis> y;
    std::optional<int> evaluation_point;
    std::optional<std::vector<float>> bins;

    
    Histogram (
        HistogramAxis x = HistogramAxis(),
        std::optional<HistogramAxis> y = {},
        std::optional<int> evaluation_point = {},
        std::optional<std::vector<float>> bins = {}
    )
    : x (
        x
    )
    , y (
        y
    )
    , evaluation_point (
        evaluation_point
    )
    , bins (
        bins
    )
    {
    }

    bool operator == (const Histogram &other) const {
        if (x != other.x) return false;
        if (y != other.y) return false;
        if (evaluation_point != other.evaluation_point) return false;
        if (bins != other.bins) return false;
        return true;
    }
    bool operator != (const Histogram &other) const {return not(*this==other);}
    std::string json (void) const {
        return Histogram_to_json_string(*this);
    }
}; // Histogram
inline
void to_json(json &j, const Histogram &obj) try {
    j = json::object();
    j["x"] = obj.x;
    if(obj.y.has_value())
        j["y"] = obj.y.value();
    if(obj.evaluation_point.has_value())
        j["evaluation_point"] = obj.evaluation_point.value();
    if(obj.bins.has_value())
        j["bins"] = obj.bins.value();
} catch (const std::exception &e) {
    std::throw_with_nested(std::runtime_error("void to_json(json &j, const Histogram &obj) exception"));
}

inline
std::string Histogram_to_json_string(const Histogram &obj) {
    json j;
    to_json(j,obj);
    return j.dump();
}
inline
void from_json(const json &j, Histogram &obj) try {
    j.at("x").get_to(obj.x);
    if(auto it=j.find("y"); it!=j.end() and !it->is_null())
        obj.y = *it;
    if(auto it=j.find("evaluation_point"); it!=j.end() and !it->is_null())
        obj.evaluation_point = *it;
    if(auto it=j.find("bins"); it!=j.end() and !it->is_null())
        obj.bins = *it;
} catch (const std::exception &e) {
    std::throw_with_nested(std::runtime_error("void from_json(const json &j, Histogram &obj) exception"));
}
inline
Histogram Histogram_from_json(const json &j) {
    Histogram obj;
    from_json(j,obj);
    return obj;
}
} // namespace dto

