#pragma once
// 
// https://github.com/AlexanderZvyagin/dto-code-generator
// Generated by CODE GENERATOR OF DATA TRANSFER OBJECTS (cgdto) version 0.8.2
// 
// Generated from schema: MonteCarlo SDK version (0.7.0)
// 


#include <optional>
#include <string>
#include <vector>
#include <map>
#include <stdexcept>
#include <cmath>

#include <nlohmann/json.hpp>
using json = nlohmann::json;


#include "HistogramAxis.hpp"
namespace dto {
class Histogram2;
std::string Histogram2_to_json_string(const Histogram2 &obj);
class Histogram2 {
public:

    HistogramAxis AxisX;
    std::optional<HistogramAxis> AxisY;
    std::optional<HistogramAxis> AxisZ;
    std::optional<int> Flags;
    std::optional<int> EvaluationPoint;
    std::optional<int> TimeStep;
    std::optional<std::string> Title;
    std::optional<std::vector<float>> Bins;

    
    Histogram2 (
        HistogramAxis AxisX = HistogramAxis(),
        std::optional<HistogramAxis> AxisY = {},
        std::optional<HistogramAxis> AxisZ = {},
        std::optional<int> Flags = {},
        std::optional<int> EvaluationPoint = {},
        std::optional<int> TimeStep = {},
        std::optional<std::string> Title = {},
        std::optional<std::vector<float>> Bins = {}
    )
    : AxisX (
        AxisX
    )
    , AxisY (
        AxisY
    )
    , AxisZ (
        AxisZ
    )
    , Flags (
        Flags
    )
    , EvaluationPoint (
        EvaluationPoint
    )
    , TimeStep (
        TimeStep
    )
    , Title (
        Title
    )
    , Bins (
        Bins
    )
    {
    }

    bool operator == (const Histogram2 &other) const {
        if (AxisX != other.AxisX) return false;
        if (AxisY != other.AxisY) return false;
        if (AxisZ != other.AxisZ) return false;
        if (Flags != other.Flags) return false;
        if (EvaluationPoint != other.EvaluationPoint) return false;
        if (TimeStep != other.TimeStep) return false;
        if (Title != other.Title) return false;
        if (Bins != other.Bins) return false;
        return true;
    }
    bool operator != (const Histogram2 &other) const {return not(*this==other);}
    std::string json (void) const {
        return Histogram2_to_json_string(*this);
    }
}; // Histogram2
inline
void to_json(json &j, const Histogram2 &obj) try {
    j = json::object();
    j["AxisX"] = obj.AxisX;
    if(obj.AxisY.has_value())
        j["AxisY"] = obj.AxisY.value();
    if(obj.AxisZ.has_value())
        j["AxisZ"] = obj.AxisZ.value();
    if(obj.Flags.has_value())
        j["Flags"] = obj.Flags.value();
    if(obj.EvaluationPoint.has_value())
        j["EvaluationPoint"] = obj.EvaluationPoint.value();
    if(obj.TimeStep.has_value())
        j["TimeStep"] = obj.TimeStep.value();
    if(obj.Title.has_value())
        j["Title"] = obj.Title.value();
    if(obj.Bins.has_value())
        j["Bins"] = obj.Bins.value();
} catch (const std::exception &e) {
    std::throw_with_nested(std::runtime_error("void to_json(json &j, const Histogram2 &obj) exception"));
}

inline
std::string Histogram2_to_json_string(const Histogram2 &obj) {
    json j;
    to_json(j,obj);
    return j.dump();
}
inline
void from_json(const json &j, Histogram2 &obj) try {
    j.at("AxisX").get_to(obj.AxisX);
    if(auto it=j.find("AxisY"); it!=j.end() and !it->is_null())
        obj.AxisY = *it;
    if(auto it=j.find("AxisZ"); it!=j.end() and !it->is_null())
        obj.AxisZ = *it;
    if(auto it=j.find("Flags"); it!=j.end() and !it->is_null())
        obj.Flags = *it;
    if(auto it=j.find("EvaluationPoint"); it!=j.end() and !it->is_null())
        obj.EvaluationPoint = *it;
    if(auto it=j.find("TimeStep"); it!=j.end() and !it->is_null())
        obj.TimeStep = *it;
    if(auto it=j.find("Title"); it!=j.end() and !it->is_null())
        obj.Title = *it;
    if(auto it=j.find("Bins"); it!=j.end() and !it->is_null())
        obj.Bins = *it;
} catch (const std::exception &e) {
    std::throw_with_nested(std::runtime_error("void from_json(const json &j, Histogram2 &obj) exception"));
}
inline
Histogram2 Histogram2_from_json(const json &j) {
    Histogram2 obj;
    from_json(j,obj);
    return obj;
}
} // namespace dto

